import requests
import pandas as pd
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
import os
import datetime
import tkinter as tk
from tkinter import ttk, messagebox, Toplevel
import threading
import time
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
import logging

# Set working directory to the script's directory
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# Create data folder if not exists
data_folder = os.path.join(script_dir, 'data')
try:
    os.makedirs(data_folder, exist_ok=True)
except Exception as e:
    logging.error(f"Failed to create data folder: {e}")

# Set up logging to file and console
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(script_dir, 'trace_download.log')),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class UtilityApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Contrast Traces Utility")
        self.root.geometry("600x400")

        # Button frame
        self.button_frame = ttk.Frame(self.root)
        self.button_frame.pack(pady=10)
        self.fetch_button = ttk.Button(self.button_frame, text="Fetch", command=self.start_fetch)
        self.fetch_button.pack()

        # Log frame
        self.log_frame = ttk.Frame(self.root)
        self.log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.log_text = tk.Text(self.log_frame, height=20, width=70, state='disabled')
        self.log_text.pack(fill=tk.BOTH, expand=True)
        scrollbar = ttk.Scrollbar(self.log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text['yscrollcommand'] = scrollbar.set

    def log(self, message):
        logger.info(message)
        self.log_text.configure(state='normal')
        self.log_text.insert(tk.END, f"{datetime.datetime.now().strftime('%H:%M:%S')}: {message}\n")
        self.log_text.configure(state='disabled')
        self.log_text.see(tk.END)
        self.root.update_idletasks()

    def start_fetch(self):
        self.fetch_button.config(state='disabled')
        threading.Thread(target=self.run_logic, daemon=True).start()

    def show_final_xlsx_popup(self, final_file, app_aliases, traces_counts, date_formatted):
        try:
            wb = openpyxl.load_workbook(final_file)
            ws = wb.active
        except Exception as e:
            self.log(f"Error loading Final.xlsx for popup: {e}")
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to load Final.xlsx: {e}"))
            return

        # Create popup window
        popup = Toplevel(self.root)
        popup.title("Final.xlsx Data")
        popup.geometry("800x500")

        # Frame for Treeview and controls
        tree_frame = ttk.Frame(popup)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Treeview for displaying data
        columns = ['Applications'] + [ws.cell(row=1, column=col).value for col in range(2, ws.max_column + 1)]
        tree = ttk.Treeview(tree_frame, columns=columns, show='headings')
        tree.pack(fill=tk.BOTH, expand=True)

        # Set column headings and alignments
        for col in columns:
            tree.heading(col, text=col)
            tree.column(col, anchor='w' if col == 'Applications' else 'center', width=100)

        # Style for Treeview
        style = ttk.Style()
        style.configure("Treeview.Heading", font=('Helvetica', 10, 'bold'))
        style.configure("Treeview", rowheight=25, font=('Helvetica', 10))
        style.configure("Bold.Treeview", font=('Helvetica', 10, 'bold'))
        style.configure("Green.Treeview", background='#90EE90')

        # Insert data
        total_row_id = None
        for row in range(2, ws.max_row + 1):
            values = []
            tags = []
            is_total = ws.cell(row=row, column=1).value == 'Total'
            for col in range(1, ws.max_column + 1):
                cell = ws.cell(row=row, column=col)
                value = cell.value if cell.value is not None else ''
                if col == 1:
                    values.append(value)
                    if value in app_aliases.values() or is_total:
                        tags.append('bold')
                else:
                    if isinstance(value, (int, float)) and value > 0:
                        values.append(str(value))
                    else:
                        values.append('')
                        if cell.fill.start_color.rgb == 'FF90EE90':
                            tags.append('green')
            item_id = tree.insert('', 'end', values=values, tags=tags)
            if is_total:
                total_row_id = item_id

        # Apply bold and green tags
        tree.tag_configure('bold', font=('Helvetica', 10, 'bold'))
        tree.tag_configure('green', background='#90EE90')

        # Add grid lines
        style.configure("Treeview", borderwidth=1, relief="solid")
        for col in columns:
            tree.column(col, stretch=False)

        # Deselect on click outside
        def deselect_tree(event):
            if tree.identify_region(event.x, event.y) not in ('cell', 'heading'):
                tree.selection_remove(tree.selection())

        popup.bind('<Button-1>', deselect_tree)

        # Copy functionality
        def copy_selection(event=None):
            selected_items = tree.selection()
            if selected_items:
                copied_data = []
                for item in selected_items:
                    values = tree.item(item, 'values')
                    copied_data.append('\t'.join(map(str, values)))
                popup.clipboard_clear()
                popup.clipboard_append('\n'.join(copied_data))
                self.log("Selected rows copied to clipboard")

        tree.bind('<Control-c>', copy_selection)
        tree.bind('<Button-3>', lambda event: copy_selection())

        # Column deletion controls
        delete_frame = ttk.Frame(popup)
        delete_frame.pack(pady=10)
        ttk.Label(delete_frame, text="Select Date Column to Delete:").pack(side='left', padx=5)
        column_var = tk.StringVar()
        date_columns = [col for col in columns if col != 'Applications']
        column_dropdown = ttk.Combobox(delete_frame, textvariable=column_var, values=date_columns, state='readonly')
        column_dropdown.pack(side='left', padx=5)

        def delete_column():
            selected_column = column_var.get()
            if not selected_column:
                messagebox.showwarning("Warning", "Please select a column to delete", parent=popup)
                return
            if selected_column == 'Applications':
                messagebox.showerror("Error", "Cannot delete Applications column", parent=popup)
                return

            # Update Treeview
            new_columns = [col for col in columns if col != selected_column]
            tree['columns'] = new_columns
            for col in new_columns:
                tree.heading(col, text=col)
                tree.column(col, anchor='w' if col == 'Applications' else 'center', width=100)
            for item in tree.get_children():
                values = tree.item(item, 'values')
                new_values = [values[0]] + [values[columns.index(col)] for col in new_columns if col != 'Applications']
                tree.item(item, values=new_values)

            # Update Final.xlsx
            try:
                wb = openpyxl.load_workbook(final_file)
                ws = wb.active
                for col in range(ws.max_column, 1, -1):
                    if ws.cell(row=1, column=col).value == selected_column:
                        ws.delete_cols(col)
                        wb.save(final_file)
                        self.log(f"Deleted column {selected_column} from Final.xlsx")
                        break
                column_dropdown['values'] = [col for col in new_columns if col != 'Applications']
                column_var.set('')
            except Exception as e:
                self.log(f"Error deleting column {selected_column} from Final.xlsx: {e}")
                messagebox.showerror("Error", f"Failed to delete column: {e}", parent=popup)

        delete_button = ttk.Button(delete_frame, text="Delete Selected Column", command=delete_column)
        delete_button.pack(side='left', padx=5)

        popup.protocol("WM_DELETE_WINDOW", lambda: popup.destroy())

    def run_logic(self):
        self.log("Starting utility...")

        # API credentials (replace with actual values)
        contrast_token = '<<TOKEN>>'
        org_uuid = '<<UUID>>'
        api_key = '<<APIKEY>>'

        # Validate credentials
        if '<<' in contrast_token or '<<' in org_uuid or '<<' in api_key:
            self.log("Error: Please replace <<TOKEN>>, <<UUID>>, and <<APIKEY>> with actual credentials")
            self.fetch_button.config(state='normal')
            self.root.after(0, lambda: messagebox.showerror("Error", "Invalid API credentials"))
            return

        # Base URL
        base_url = 'https://contrast.abc.com/Contrast/api/ng/'

        # Headers
        headers = {
            'Authorization': contrast_token,
            'Api-key': api_key,
            'Accept': 'application/json'
        }

        # Define 14 application IDs and their aliases
        app_aliases = {
            'hhdjdjdjd': 'CRM',
            'kkdjdj': 'DRM',
            'app_id3': 'App3',
            'app_id4': 'App4',
            'app_id5': 'App5',
            'app_id6': 'App6',
            'app_id7': 'App7',
            'app_id8': 'App8',
            'app_id9': 'App9',
            'app_id10': 'App10',
            'app_id11': 'App11',
            'app_id12': 'App12',
            'app_id13': 'App13',
            'app_id14': 'App14'
        }
        app_ids = list(app_aliases.keys())

        # Current date
        today = datetime.datetime.now()
        today_str = today.strftime('%Y-%m-%d')
        date_formatted = today.strftime('%d-%b-%Y')
        daily_file = os.path.join(data_folder, f'Contrast_Traces_{today_str}.xlsx')

        # Step 1: Download traces and save to daily Excel
        self.log(f"Downloading traces for {today_str}...")
        daily_data = []
        traces_counts = {alias: 0 for alias in app_aliases.values()}

        with requests.Session() as session:
            session.headers.update(headers)
            for app_id in app_ids:
                alias = app_aliases[app_id]
                self.log(f"Fetching traces for {alias} ({app_id}) with status 'Reported'...")
                offset = 0
                limit = 500
                delay = 0.5
                while True:
                    url = f"{base_url}{org_uuid}/orgtraces/ids?status=Reported&applicationID={app_id}&limit={limit}&offset={offset}&sort=-last_time_seen"
                    try:
                        @retry(
                            stop=stop_after_attempt(3),
                            wait=wait_exponential(multiplier=1, min=4, max=10),
                            retry=retry_if_exception_type((requests.exceptions.RequestException,))
                        )
                        def make_request():
                            return session.get(url, timeout=30)

                        response = make_request()
                        if response.status_code == 200:
                            data = response.json()
                            self.log(f"Raw API response for {alias} at offset {offset}: {data}")
                            traces_fetched = []
                            if isinstance(data, list):
                                traces_fetched = data
                            elif isinstance(data, dict):
                                traces_fetched = data.get('traces', []) or data.get('ids', [])
                            else:
                                self.log(f"Unexpected response format for {alias}: {type(data)}")
                                break

                            self.log(f"Fetched {len(traces_fetched)} traces for {alias} at offset {offset}")
                            for trace in traces_fetched:
                                trace_id = trace if isinstance(trace, str) else trace.get('uuid', trace.get('id', ''))
                                if trace_id:
                                    daily_data.append({
                                        'Date': date_formatted,
                                        'Application': alias,
                                        'Trace': trace_id
                                    })
                                    traces_counts[alias] += 1
                            if len(traces_fetched) < limit:
                                break
                            offset += limit
                            time.sleep(delay)
                        elif response.status_code == 429:
                            self.log(f"Rate limit exceeded for {alias}. Waiting longer...")
                            time.sleep(5)
                            continue
                        else:
                            self.log(f"Error fetching traces for {alias}: {response.status_code} - {response.text}")
                            break
                    except Exception as e:
                        self.log(f"Exception fetching traces for {alias} at offset {offset}: {e}")
                        break

        # Save daily traces to Excel
        self.log(f"Saving daily traces to {daily_file}...")
        try:
            df = pd.DataFrame(daily_data if daily_data else [{'Date': date_formatted, 'Application': '', 'Trace': ''}])
            df.to_excel(daily_file, index=False)
            wb = openpyxl.load_workbook(daily_file)
            ws = wb.active
            ws.title = 'Traces'

            thin_border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))
            for col in range(1, 4):
                cell = ws.cell(row=1, column=col)
                cell.font = Font(bold=True)
                cell.alignment = Alignment(horizontal='center')
                cell.border = thin_border

            for row in range(2, ws.max_row + 1):
                for col in range(1, 4):
                    cell = ws.cell(row=row, column=col)
                    cell.alignment = Alignment(horizontal='center' if col > 1 else 'left')
                    cell.border = thin_border

            wb.save(daily_file)
            self.log(f"Daily traces saved to {daily_file} (Total: {len(daily_data)})")
        except Exception as e:
            self.log(f"Error saving daily traces to {daily_file}: {e}")
            self.fetch_button.config(state='normal')
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to save daily traces: {e}"))
            return

        # Step 2: Update Final.xlsx with counts
        self.log("Updating Final.xlsx...")
        final_file = os.path.join(script_dir, 'Final.xlsx')
        try:
            final_wb = openpyxl.load_workbook(final_file)
        except FileNotFoundError:
            self.log("Final.xlsx not found, creating new...")
            final_wb = openpyxl.Workbook()
            final_ws = final_wb.active
            final_ws.title = 'Summary'
            final_ws['A1'] = 'Applications'
            for row, alias in enumerate(app_aliases.values(), start=2):
                final_ws.cell(row=row, column=1).value = alias
                final_ws.cell(row=row, column=1).font = Font(bold=True)  # Bold application list
            total_row = len(app_aliases) + 2
            final_ws.cell(row=total_row, column=1).value = 'Total'
            final_ws.cell(row=total_row, column=1).font = Font(bold=True)

        final_ws = final_wb.active

        # Find or add date column
        date_column = None
        last_column = final_ws.max_column
        for col in range(2, last_column + 1):
            if final_ws.cell(row=1, column=col).value == date_formatted:
                date_column = col
                self.log(f"Overwriting existing column for {date_formatted} at column {col}")
                break
        if date_column is None:
            date_column = last_column + 1
            final_ws.cell(row=1, column=date_column).value = date_formatted
            self.log(f"Adding new column for {date_formatted} at column {date_column}")

        # Clear existing data in the column (except header)
        for row in range(2, final_ws.max_row + 1):
            final_ws.cell(row=row, column=date_column).value = None
            final_ws.cell(row=row, column=date_column).fill = PatternFill()

        # Update counts
        green_fill = PatternFill(start_color='90EE90', end_color='90EE90', fill_type='solid')
        for row in range(2, final_ws.max_row):
            app_cell = final_ws.cell(row=row, column=1)
            if app_cell.value in traces_counts:
                count = traces_counts[app_cell.value]
                count_cell = final_ws.cell(row=row, column=date_column)
                if count > 0:
                    count_cell.value = count
                else:
                    count_cell.fill = green_fill

        # Update total row
        total_row = final_ws.max_row
        if final_ws.cell(row=total_row, column=1).value == 'Total':
            sum_formula = f"=SUM({openpyxl.utils.get_column_letter(date_column)}2:{openpyxl.utils.get_column_letter(date_column)}{total_row-1})"
            total_cell = final_ws.cell(row=total_row, column=date_column)
            total_cell.value = sum_formula
            total_cell.font = Font(bold=True)
        else:
            total_row = final_ws.max_row + 1
            final_ws.cell(row=total_row, column=1).value = 'Total'
            final_ws.cell(row=total_row, column=1).font = Font(bold=True)
            sum_formula = f"=SUM({openpyxl.utils.get_column_letter(date_column)}2:{openpyxl.utils.get_column_letter(date_column)}{total_row-1})"
            total_cell = final_ws.cell(row=total_row, column=date_column)
            total_cell.value = sum_formula
            total_cell.font = Font(bold=True)

        # Apply formatting to Final.xlsx
        thin_border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))
        for col in range(1, final_ws.max_column + 1):
            cell = final_ws.cell(row=1, column=col)
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border

        for row in range(2, final_ws.max_row + 1):
            cell = final_ws.cell(row=row, column=1)
            cell.alignment = Alignment(horizontal='left')
            cell.border = thin_border
            cell.font = Font(bold=True) if row != total_row else Font(bold=True)

        for row in range(2, final_ws.max_row + 1):
            for col in range(2, final_ws.max_column + 1):
                cell = final_ws.cell(row=row, column=col)
                cell.alignment = Alignment(horizontal='center')
                cell.border = thin_border
                if row == total_row:
                    cell.font = Font(bold=True)

        # Save Final.xlsx
        try:
            final_wb.save(final_file)
            self.log(f"Final.xlsx updated with counts for {date_formatted}")
        except Exception as e:
            self.log(f"Error saving Final.xlsx: {e}")
            self.fetch_button.config(state='normal')
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to save Final.xlsx: {e}"))
            return

        # Show Final.xlsx in popup
        self.show_final_xlsx_popup(final_file, app_aliases, traces_counts, date_formatted)

        self.log("Utility completed.")
        self.fetch_button.config(state='normal')
        self.root.after(0, lambda: messagebox.showinfo("Success", f"Traces downloaded and Final.xlsx updated for {date_formatted}"))

if __name__ == "__main__":
    root = tk.Tk()
    app = UtilityApp(root)
    root.mainloop()