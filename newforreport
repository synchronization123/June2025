import os
import json
import time
import requests
import pandas as pd
from tkinter import Tk, ttk, Text, Scrollbar, END, messagebox, Toplevel, filedialog
import base64
import io
import re
from openpyxl import load_workbook
from openpyxl.styles import Alignment
import webbrowser

# Get the current directory of the script
current_dir = os.path.dirname(os.path.abspath(__file__))

# Path for token file, debug file, and username file
TOKEN_FILE = os.path.join(current_dir, 'token.json')
DEBUG_FILE = os.path.join(current_dir, 'response_debug.txt')
USERNAME_FILE = os.path.join(current_dir, 'username.xlsx')

# Hardcoded usernames (replace placeholders user1-user20 with actual usernames)
USERNAMES = [
    'sam.tam', 'din.time', 'jh.jk',
    'user1', 'user2', 'user3', 'user4', 'user5',
    'user6', 'user7', 'user8', 'user9', 'user10',
    'user11', 'user12', 'user13', 'user14', 'user15',
    'user16', 'user17', 'user18', 'user19', 'user20'
]

# Hardcoded VAPT categories
VAPT_CATEGORIES = [
    'SQL Injection',
    'Cross-Site Scripting (XSS)',
    'Cross-Site Request Forgery (CSRF)',
    'Insecure Direct Object References (IDOR)',
    'Security Misconfiguration',
    'Sensitive Data Exposure',
    'Missing Function Level Access Control',
    'Using Components with Known Vulnerabilities',
    'Insufficient Logging and Monitoring',
    'Broken Authentication',
    'Broken Access Control',
    'XML External Entities (XXE)',
    'Insecure Deserialization',
    'Server-Side Request Forgery (SSRF)',
    'Open Redirects',
    'File Upload Vulnerabilities',
    'Command Injection',
    'Path Traversal',
    'API Security Issues',
    'Mobile Security Issues'
]

def show_loading_dialog(parent):
    """Show a modal loading dialog."""
    loading_dialog = Toplevel(parent)
    loading_dialog.title("Processing")
    loading_dialog.geometry("250x120")
    loading_dialog.transient(parent)  # Make it modal
    loading_dialog.grab_set()  # Block interaction with main window
    frame = ttk.Frame(loading_dialog, padding="10")
    frame.pack(fill='both', expand=True)
    ttk.Label(frame, text="Loading...", font=("Helvetica", 12, "bold")).pack(pady=20)
    loading_dialog.resizable(False, False)
    # Center the dialog
    loading_dialog.update_idletasks()
    x = parent.winfo_x() + (parent.winfo_width() - loading_dialog.winfo_width()) // 2
    y = parent.winfo_y() + (parent.winfo_height() - loading_dialog.winfo_height()) // 2
    loading_dialog.geometry(f"+{x}+{y}")
    return loading_dialog

def show_retry_dialog(parent, message):
    """Show a retry/stop dialog for errors."""
    retry_dialog = Toplevel(parent)
    retry_dialog.title("Error")
    retry_dialog.geometry("300x150")
    retry_dialog.transient(parent)
    retry_dialog.grab_set()
    frame = ttk.Frame(retry_dialog, padding="10")
    frame.pack(fill='both', expand=True)
    ttk.Label(frame, text=message, wraplength=250).pack(pady=10)
    retry_var = [False]  # Use list to modify in nested function
    
    def on_retry():
        retry_var[0] = True
        retry_dialog.destroy()
    
    def on_stop():
        retry_var[0] = False
        retry_dialog.destroy()
    
    ttk.Button(frame, text="Retry", command=on_retry).pack(side='left', padx=5, pady=10)
    ttk.Button(frame, text="Stop", command=on_stop).pack(side='right', padx=5, pady=10)
    
    # Center the dialog
    retry_dialog.update_idletasks()
    x = parent.winfo_x() + (parent.winfo_width() - retry_dialog.winfo_width()) // 2
    y = parent.winfo_y() + (parent.winfo_height() - retry_dialog.winfo_height()) // 2
    retry_dialog.geometry(f"+{x}+{y}")
    retry_dialog.resizable(False, False)
    
    parent.wait_window(retry_dialog)
    return retry_var[0]

def show_missing_comments_prompt(parent, missing_comments_df, version):
    """Show a table of Jiras with no matching comments."""
    prompt = Toplevel(parent)
    prompt.title(f"Jiras with No Comments for {version}")
    prompt.geometry("600x400")
    
    frame = ttk.Frame(prompt, padding="10")
    frame.pack(fill='both', expand=True)
    
    ttk.Label(frame, text=f"Jiras where comments for {version} are not found:").pack(anchor='w', pady=5)
    
    tree = ttk.Treeview(frame, columns=('Issue key', 'Status', 'Test Approach', 'Comment'), show='headings', height=10)
    tree.heading('Issue key', text='Issue key')
    tree.heading('Status', text='Status')
    tree.heading('Test Approach', text='Test Approach')
    tree.heading('Comment', text='Comment')
    tree.column('Issue key', width=150)
    tree.column('Status', width=100)
    tree.column('Test Approach', width=150)
    tree.column('Comment', width=150)
    
    scrollbar = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
    tree.configure(yscrollcommand=scrollbar.set)
    tree.pack(side='left', fill='both', expand=True)
    scrollbar.pack(side='right', fill='y')
    
    for _, row in missing_comments_df.iterrows():
        tree.insert('', 'end', values=(row['Issue key'], row['Status'], row['Test Approach'], ''))
    
    ttk.Button(frame, text="Close", command=prompt.destroy).pack(pady=10)
    
    prompt.update_idletasks()
    x = parent.winfo_x() + (parent.winfo_width() - prompt.winfo_width()) // 2
    y = parent.winfo_y() + (parent.winfo_height() - prompt.winfo_height()) // 2
    prompt.geometry(f"+{x}+{y}")
    prompt.resizable(False, False)

def create_username_file():
    """Create username.xlsx with hardcoded usernames in the current directory."""
    while True:
        try:
            text.insert(END, f"Creating username.xlsx...\n")
            # Check if directory is writable
            if not os.access(current_dir, os.W_OK):
                raise PermissionError(f"No write permission for directory: {current_dir}")
            
            # Create DataFrame with usernames
            df = pd.DataFrame({'Username': USERNAMES})
            
            # Write the file
            df.to_excel(USERNAME_FILE, index=False, engine='openpyxl')
            text.insert(END, f"Saved username.xlsx to {USERNAME_FILE}\n")
            text.see(END)
            break
        
        except PermissionError as e:
            text.insert(END, f"Error creating username.xlsx: {str(e)}\n")
            if not show_retry_dialog(root, f"Cannot write {USERNAME_FILE}: {str(e)}. Retry or stop?"):
                text.insert(END, "Stopping username.xlsx creation.\n")
                return False
        except Exception as e:
            text.insert(END, f"Error creating username.xlsx: {str(e)}\n")
            if not show_retry_dialog(root, f"Failed to create username.xlsx: {str(e)}. Retry or stop?"):
                text.insert(END, "Stopping username.xlsx creation.\n")
                return False
    return True

def save_token():
    """Save or update the entered token to token.json and hide the file."""
    token = entry_api_token.get().strip()
    if not token or token == '*******':
        messagebox.showerror("Error", "Please enter a valid API token.")
        return
    while True:
        try:
            # Check if directory is writable
            if not os.access(current_dir, os.W_OK):
                raise PermissionError(f"No write permission for directory: {current_dir}")
            
            with open(TOKEN_FILE, 'w') as token_file:
                json.dump({'token': token}, token_file, indent=2)
            # Hide the token file (Windows-specific)
            os.system(f'attrib +h "{TOKEN_FILE}"')
            entry_api_token.delete(0, END)
            entry_api_token.insert(0, '*******')  # Mask token after saving
            text.insert(END, "Token saved/updated successfully.\n")
            text.see(END)
            update_token_status()
            break
        
        except PermissionError as e:
            text.insert(END, f"Error saving token: {str(e)}\n")
            if not show_retry_dialog(root, f"Cannot write {TOKEN_FILE}: {str(e)}. Retry or stop?"):
                text.insert(END, "Stopping token save.\n")
                return
        except Exception as e:
            text.insert(END, f"Error saving token: {str(e)}\n")
            if not show_retry_dialog(root, f"Failed to save token: {str(e)}. Retry or stop?"):
                text.insert(END, "Stopping token save.\n")
                return

def load_token():
    """Load the token from token.json if it exists."""
    if os.path.exists(TOKEN_FILE):
        try:
            # Check if file is readable
            if not os.access(TOKEN_FILE, os.R_OK):
                raise PermissionError(f"No read permission for file: {TOKEN_FILE}")
            
            with open(TOKEN_FILE, 'r') as token_file:
                data = json.load(token_file)
                token = data.get('token', '')
                if not token:
                    raise ValueError("Token field is empty in token.json")
                return token
        except json.JSONDecodeError as e:
            text.insert(END, f"Error reading token.json: Invalid JSON format - {str(e)}\n")
            return ''
        except PermissionError as e:
            text.insert(END, f"Error reading token.json: {str(e)}\n")
            return ''
        except Exception as e:
            text.insert(END, f"Error reading token.json: {str(e)}\n")
            return ''
    return ''

def update_token_status():
    """Update the token status label color and text."""
    token = entry_api_token.get().strip()
    if token == '*******' or token:
        token_status_label.config(text="Token present", foreground="green")
    else:
        token_status_label.config(text="Token blank", foreground="red")

def process_comments(comment):
    """Extract username and clean comment based on pattern DD/MMM/YY HH:MM AM/PM; username; comment."""
    if pd.isna(comment) or not comment:
        return '', ''
    
    # Match pattern like "11/Aug/25 1:27 AM; sim.tim; actual comment"
    pattern = r'^\d{2}/[A-Za-z]{3}/\d{2}\s+\d{1,2}:\d{2}\s+[AP]M;\s*([^;]+);\s*(.*)$'
    match = re.match(pattern, comment.strip(), re.DOTALL)
    
    if match:
        username = match.group(1).strip()
        cleaned_comment = match.group(2).strip()
        return username, cleaned_comment
    else:
        return '', comment.strip()

def fetch_data():
    # Disable buttons and show loading dialog
    btn_save_token.config(state='disabled')
    btn_fetch.config(state='disabled')
    loading_dialog = show_loading_dialog(root)
    root.update()
    
    token = entry_api_token.get().strip()
    version = entry_version.get().strip()
    
    # If token is masked, try to load the actual token from file
    if token == '*******':
        token = load_token()
        if not token:
            messagebox.showerror("Error", "No saved token found. Please enter and save a valid token.")
            btn_save_token.config(state='normal')
            btn_fetch.config(state='normal')
            loading_dialog.destroy()
            return
    
    if not token or not version:
        messagebox.showerror("Error", "Please fill in all fields.")
        btn_save_token.config(state='normal')
        btn_fetch.config(state='normal')
        loading_dialog.destroy()
        return
    
    # Create username.xlsx
    if not create_username_file():
        btn_save_token.config(state='normal')
        btn_fetch.config(state='normal')
        loading_dialog.destroy()
        return
    
    text.insert(END, "Starting Jira data fetch...\n")
    
    # Form the R version
    r_version = version
    if version.lower().startswith('v'):
        r_version = 'R' + version[1:]
    else:
        r_version = 'R' + version
    
    # Form JQL
    jql = f'"Build(s)" in ({version}) OR "Build(s)" in ({r_version})'
    
    text.insert(END, f"Formed JQL: {jql}\n")
    
    try:
        # Try Bearer token authentication
        headers_bearer = {
            'Authorization': f'Bearer {token}',
            'Accept': 'text/csv'
        }
        
        # CSV export endpoint
        url = f'https://jira.crm.com/sr/jira.issueviews:searchrequest-csv-all-fields/temp/SearchRequest.csv?jqlQuery={jql}'
        
        while True:
            try:
                text.insert(END, "Attempting fetch with Bearer token...\n")
                response = requests.get(url, headers=headers_bearer)
                text.insert(END, f"API Response Status (Bearer): {response.status_code}\n")
                
                # Save raw response to debug file
                with open(DEBUG_FILE, 'w', encoding='utf-8') as debug_file:
                    debug_file.write(response.text)
                text.insert(END, f"Raw response saved to: {DEBUG_FILE}\n")
                
                if response.status_code != 200:
                    # Try Basic Auth as a fallback
                    text.insert(END, "Bearer token failed, attempting Basic Auth...\n")
                    auth_string = f"user@example.com:{token}"  # Replace with your Jira email
                    auth_bytes = auth_string.encode('ascii')
                    auth_base64 = base64.b64encode(auth_bytes).decode('ascii')
                    headers_basic = {
                        'Authorization': f'Basic {auth_base64}',
                        'Accept': 'text/csv'
                    }
                    
                    response = requests.get(url, headers=headers_basic)
                    text.insert(END, f"API Response Status (Basic): {response.status_code}\n")
                    
                    # Save raw response to debug file
                    with open(DEBUG_FILE, 'w', encoding='utf-8') as debug_file:
                        debug_file.write(response.text)
                    text.insert(END, f"Raw response saved to: {DEBUG_FILE}\n")
                    
                    if response.status_code != 200:
                        text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
                        raise requests.exceptions.RequestException(f"Non-200 status: {response.status_code}")
                break
            
            except requests.exceptions.RequestException as e:
                text.insert(END, f"API Request Error: {str(e)}\n")
                if not show_retry_dialog(root, f"API request failed: {str(e)}. Retry or stop?"):
                    text.insert(END, "Stopping data fetch.\n")
                    btn_save_token.config(state='normal')
                    btn_fetch.config(state='normal')
                    loading_dialog.destroy()
                    if os.path.exists(DEBUG_FILE):
                        os.remove(DEBUG_FILE)
                    if os.path.exists(USERNAME_FILE):
                        os.remove(USERNAME_FILE)
                    return
        
        # Parse CSV response
        try:
            df = pd.read_csv(io.StringIO(response.text))
            text.insert(END, f"Fetched {len(df)} issues.\n")
        except pd.errors.ParserError as e:
            text.insert(END, f"CSV Parse Error: {str(e)}\n")
            text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
            if not show_retry_dialog(root, f"Failed to parse CSV: {str(e)}. Retry or stop?"):
                text.insert(END, "Stopping data fetch.\n")
                btn_save_token.config(state='normal')
                btn_fetch.config(state='normal')
                loading_dialog.destroy()
                if os.path.exists(DEBUG_FILE):
                    os.remove(DEBUG_FILE)
                if os.path.exists(USERNAME_FILE):
                    os.remove(USERNAME_FILE)
                return
        
        text.insert(END, f"Total issues fetched: {len(df)}\n")
        
        if not df.empty:
            # Save to temporary Excel to process
            temp_filename = os.path.join(current_dir, f"temp_{version}_data.xlsx")
            df.to_excel(temp_filename, index=False, engine='openpyxl')
            
            # Load back for processing
            df = pd.read_excel(temp_filename)
            
            # Step 1: Delete columns except Issue key, Issue Type, Status, Component/s*, Comment*
            columns_to_keep = [col for col in df.columns if col in ['Issue key', 'Issue Type', 'Status'] or col.startswith('Component/s') or col.startswith('Comment')]
            df = df[columns_to_keep]
            
            # Step 2: Add Test Approach column
            df['Test Approach'] = 'Functional Jira'
            component_columns = [col for col in df.columns if col.startswith('Component/s')]
            for col in component_columns:
                df.loc[df[col].str.contains('Security|AppSecurity', na=False, case=False), 'Test Approach'] = 'Security Jira'
            
            # Delete component columns
            df = df.drop(columns=component_columns)
            
            # Step 3: Load usernames from username.xlsx
            if os.path.exists(USERNAME_FILE):
                usernames_df = pd.read_excel(USERNAME_FILE)
                usernames = usernames_df['Username'].str.lower().tolist()
            else:
                usernames = []
                text.insert(END, "Warning: username.xlsx not found. Skipping comment filtering.\n")
            
            # Filter and append comments to a single column
            comment_columns = [col for col in df.columns if col.startswith('Comment')]
            df['Filtered Comments'] = ''
            df['Changelog Reviewer'] = ''
            
            for index, row in df.iterrows():
                filtered_comments = []
                changelog_reviewers = []
                for col in comment_columns:
                    comment = str(row[col]) if pd.notna(row[col]) else ''
                    if comment:
                        comment_lower = comment.lower()
                        username_match = any(username in comment_lower for username in usernames)
                        version_match = version.lower() in comment_lower
                        if username_match and version_match:
                            username, cleaned_comment = process_comments(comment)
                            if cleaned_comment:
                                filtered_comments.append(cleaned_comment)
                            if username:
                                changelog_reviewers.append(username)
                        else:
                            df.at[index, col] = ''  # Erase non-matching comments
                df.at[index, 'Filtered Comments'] = '\n\n'.join(filtered_comments)
                df.at[index, 'Changelog Reviewer'] = ', '.join(changelog_reviewers) if changelog_reviewers else ''
            
            # Delete original comment columns
            df = df.drop(columns=comment_columns)
            
            # Step 4: Add Manual Secure Code Review and Manual Security Testing columns
            df['Manual Secure Code Review'] = 'NA'
            df['Manual Security Testing'] = 'NA'
            
            for index, row in df.iterrows():
                comment = str(row['Filtered Comments']).lower() if pd.notna(row['Filtered Comments']) else ''
                if 'secure code review: done' in comment:
                    df.at[index, 'Manual Secure Code Review'] = 'Done'
                elif 'secure code review: na' in comment:
                    df.at[index, 'Manual Secure Code Review'] = 'NA'
                if 'manual testing: done' in comment:
                    df.at[index, 'Manual Security Testing'] = 'Done'
                elif 'manual testing: na' in comment:
                    df.at[index, 'Manual Security Testing'] = 'NA'
            
            # Step 5: Identify Jiras with no matching comments
            missing_comments_df = df[df['Filtered Comments'] == ''][['Issue key', 'Status', 'Test Approach']].copy()
            
            # Save the processed DataFrame, handle if file is open
            filename = os.path.join(current_dir, f"{version}_data.xlsx")
            text.insert(END, f"Exporting processed data to {filename}...\n")
            while True:
                try:
                    df.to_excel(filename, index=False, engine='openpyxl')
                    
                    # Format Filtered Comments column to justify
                    wb = load_workbook(filename)
                    ws = wb.active
                    for col in ws.columns:
                        if col[0].value == 'Filtered Comments':
                            for cell in col[1:]:  # Skip header
                                cell.alignment = Alignment(horizontal='justify', vertical='top', wrap_text=True)
                    wb.save(filename)
                    
                    text.insert(END, "Export complete with formatted comments.\n")
                    text.see(END)
                    break
                except PermissionError as e:
                    text.insert(END, f"Error: {filename} is open or inaccessible: {str(e)}\n")
                    if not show_retry_dialog(root, f"Cannot write {filename}: {str(e)}. Retry or stop?"):
                        text.insert(END, "Stopping data export.\n")
                        btn_save_token.config(state='normal')
                        btn_fetch.config(state='normal')
                        loading_dialog.destroy()
                        if os.path.exists(DEBUG_FILE):
                            os.remove(DEBUG_FILE)
                        if os.path.exists(USERNAME_FILE):
                            os.remove(USERNAME_FILE)
                        if os.path.exists(temp_filename):
                            os.remove(temp_filename)
                        return
            
            # Delete username.xlsx after formatting comments
            if os.path.exists(USERNAME_FILE):
                try:
                    os.remove(USERNAME_FILE)
                    text.insert(END, f"Deleted {USERNAME_FILE}\n")
                except Exception as e:
                    text.insert(END, f"Error deleting {USERNAME_FILE}: {str(e)}\n")
            
            # Delete temporary file
            if os.path.exists(temp_filename):
                os.remove(temp_filename)
            
            # Show missing comments prompt if there are any
            if not missing_comments_df.empty:
                show_missing_comments_prompt(root, missing_comments_df, version)
            else:
                text.insert(END, f"No Jiras found with missing comments for {version}.\n")
        
        else:
            text.insert(END, "No data to export.\n")
    
    finally:
        # Re-enable buttons and destroy loading dialog
        btn_save_token.config(state='normal')
        btn_fetch.config(state='normal')
        loading_dialog.destroy()
        # Delete debug file
        if os.path.exists(DEBUG_FILE):
            os.remove(DEBUG_FILE)

# Create GUI
root = Tk()
root.title("Jira Report Generator")
root.geometry("600x400")

# Use ttk for smoother look
style = ttk.Style()
style.theme_use('clam')  # A smoother theme
style.configure('TButton', padding=6)
style.configure('TEntry', padding=5)
style.configure('TLabel', padding=3)

frame = ttk.Frame(root, padding="10")
frame.pack(fill='both', expand=True)

# API Token
ttk.Label(frame, text="Jira API Token:").grid(row=0, column=0, sticky='w', pady=5)
entry_api_token = ttk.Entry(frame, width=50, show='*')
entry_api_token.grid(row=0, column=1, pady=5)

# Token status label
token_status_label = ttk.Label(frame, text="Token blank", foreground="red")
token_status_label.grid(row=1, column=1, sticky='w', pady=5)

# Load token if it exists
try:
    saved_token = load_token()
    if saved_token:
        entry_api_token.insert(0, '*******')  # Mask token in GUI
        update_token_status()
except Exception as e:
    text = Text(frame, wrap='word', height=10, borderwidth=2, relief='flat')
    text.insert(END, f"Error loading token: {str(e)}\n")
    text.grid(row=6, column=0, columnspan=2, sticky='nsew')

# Save Token Button
btn_save_token = ttk.Button(frame, text="Save/Update Token", command=save_token)
btn_save_token.grid(row=2, column=0, columnspan=2, pady=5)

# Version
ttk.Label(frame, text="Version (e.g., v12.6.3.9999900):").grid(row=3, column=0, sticky='w', pady=5)
entry_version = ttk.Entry(frame, width=50)
entry_version.grid(row=3, column=1, pady=5)

# Fetch Button
btn_fetch = ttk.Button(frame, text="Fetch and Export Data", command=fetch_data)
btn_fetch.grid(row=4, column=0, columnspan=2, pady=10)

# Console-like text area
ttk.Label(frame, text="Console:").grid(row=5, column=0, sticky='w', pady=5)
text_frame = ttk.Frame(frame)
text_frame.grid(row=6, column=0, columnspan=2, sticky='nsew')

text = Text(text_frame, wrap='word', height=10, borderwidth=2, relief='flat')
text.pack(side='left', fill='both', expand=True)

scrollbar = Scrollbar(text_frame, command=text.yview)
scrollbar.pack(side='right', fill='y')
text.config(yscrollcommand=scrollbar.set)

# Make the text area expand
frame.rowconfigure(6, weight=1)
frame.columnconfigure(1, weight=1)

# Smooth edges for the window
root.resizable(False, False)
root.configure(bg='#f0f0f0')

root.mainloop()