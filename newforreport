import os
import json
import time
import requests
import pandas as pd
from tkinter import Tk, ttk, Text, Scrollbar, END, messagebox, Toplevel, filedialog, Canvas
import base64
import io
import re
from openpyxl import load_workbook
from openpyxl.styles import Alignment
import webbrowser
from datetime import datetime

# Get the current directory of the script
current_dir = os.path.dirname(os.path.abspath(__file__))

# Path for token file, debug file, and username file
TOKEN_FILE = os.path.join(current_dir, 'token.json')
DEBUG_FILE = os.path.join(current_dir, 'response_debug.txt')
USERNAME_FILE = os.path.join(current_dir, 'username.xlsx')

# Hardcoded usernames (replace placeholders user1-user20 with actual usernames)
USERNAMES = [
    'sam.tam', 'din.time', 'jh.jk',
    'user1', 'user2', 'user3', 'user4', 'user5',
    'user6', 'user7', 'user8', 'user9', 'user10',
    'user11', 'user12', 'user13', 'user14', 'user15',
    'user16', 'user17', 'user18', 'user19', 'user20'
]

# Hardcoded VAPT categories
VAPT_CATEGORIES = [
    'SQL Injection', 'Cross-Site Scripting (XSS)', 'Cross-Site Request Forgery (CSRF)',
    'Insecure Direct Object References (IDOR)', 'Security Misconfiguration',
    'Sensitive Data Exposure', 'Missing Function Level Access Control',
    'Using Components with Known Vulnerabilities', 'Insufficient Logging and Monitoring',
    'Broken Authentication', 'Broken Access Control', 'XML External Entities (XXE)',
    'Insecure Deserialization', 'Server-Side Request Forgery (SSRF)', 'Open Redirects',
    'File Upload Vulnerabilities', 'Command Injection', 'Path Traversal',
    'API Security Issues', 'Mobile Security Issues'
]

def show_loading_dialog(parent):
    """Show a modal loading dialog."""
    loading_dialog = Toplevel(parent)
    loading_dialog.title("Processing")
    loading_dialog.geometry("250x120")
    loading_dialog.transient(parent)
    loading_dialog.grab_set()
    frame = ttk.Frame(loading_dialog, padding="10")
    frame.pack(fill='both', expand=True)
    ttk.Label(frame, text="Loading...", font=("Helvetica", 12, "bold")).pack(pady=20)
    loading_dialog.resizable(False, False)
    loading_dialog.update_idletasks()
    x = parent.winfo_x() + (parent.winfo_width() - loading_dialog.winfo_width()) // 2
    y = parent.winfo_y() + (parent.winfo_height() - loading_dialog.winfo_height()) // 2
    loading_dialog.geometry(f"+{x}+{y}")
    return loading_dialog

def show_retry_dialog(parent, message):
    """Show a retry/stop dialog for errors."""
    retry_dialog = Toplevel(parent)
    retry_dialog.title("Error")
    retry_dialog.geometry("300x150")
    retry_dialog.transient(parent)
    retry_dialog.grab_set()
    frame = ttk.Frame(retry_dialog, padding="10")
    frame.pack(fill='both', expand=True)
    ttk.Label(frame, text=message, wraplength=250).pack(pady=10)
    retry_var = [False]
    
    def on_retry():
        retry_var[0] = True
        retry_dialog.destroy()
    
    def on_stop():
        retry_var[0] = False
        retry_dialog.destroy()
    
    ttk.Button(frame, text="Retry", command=on_retry).pack(side='left', padx=5, pady=10)
    ttk.Button(frame, text="Stop", command=on_stop).pack(side='right', padx=5, pady=10)
    
    retry_dialog.update_idletasks()
    x = parent.winfo_x() + (parent.winfo_width() - retry_dialog.winfo_width()) // 2
    y = parent.winfo_y() + (parent.winfo_height() - retry_dialog.winfo_height()) // 2
    retry_dialog.geometry(f"+{x}+{y}")
    retry_dialog.resizable(False, False)
    
    parent.wait_window(retry_dialog)
    return retry_var[0]

def show_missing_comments_prompt(parent, missing_comments_df, version):
    """Show a table of Jiras with no matching comments."""
    prompt = Toplevel(parent)
    prompt.title(f"Jiras with No Comments for {version}")
    prompt.geometry("600x400")
    
    frame = ttk.Frame(prompt, padding="10")
    frame.pack(fill='both', expand=True)
    
    ttk.Label(frame, text=f"Jiras where comments for {version} are not found:").pack(anchor='w', pady=5)
    
    tree = ttk.Treeview(frame, columns=('Issue key', 'Status', 'Test Approach', 'Comment'), show='headings', height=10)
    tree.heading('Issue key', text='Issue key')
    tree.heading('Status', text='Status')
    tree.heading('Test Approach', text='Test Approach')
    tree.heading('Comment', text='Comment')
    tree.column('Issue key', width=150)
    tree.column('Status', width=100)
    tree.column('Test Approach', width=150)
    tree.column('Comment', width=150)
    
    scrollbar = ttk.Scrollbar(frame, orient='vertical', command=tree.yview)
    tree.configure(yscrollcommand=scrollbar.set)
    tree.pack(side='left', fill='both', expand=True)
    scrollbar.pack(side='right', fill='y')
    
    for _, row in missing_comments_df.iterrows():
        tree.insert('', 'end', values=(row['Issue key'], row['Status'], row['Test Approach'], ''))
    
    ttk.Button(frame, text="Close", command=prompt.destroy).pack(pady=10)
    
    prompt.update_idletasks()
    x = parent.winfo_x() + (parent.winfo_width() - prompt.winfo_width()) // 2
    y = parent.winfo_y() + (parent.winfo_height() - prompt.winfo_height()) // 2
    prompt.geometry(f"+{x}+{y}")
    prompt.resizable(False, False)

def generate_html_report(version, df):
    """Show a form to generate the HTML report with all fields and scrollable VAPT table."""
    report_window = Toplevel(root)
    report_window.title(f"Generate {version} Build Report")
    report_window.geometry("800x600")
    
    # Main frame with scrollable canvas
    main_frame = ttk.Frame(report_window)
    main_frame.pack(fill='both', expand=True)
    
    canvas = Canvas(main_frame)
    canvas.pack(side='left', fill='both', expand=True)
    
    scrollbar = ttk.Scrollbar(main_frame, orient='vertical', command=canvas.yview)
    scrollbar.pack(side='right', fill='y')
    
    frame = ttk.Frame(canvas)
    canvas_frame = canvas.create_window((0, 0), window=frame, anchor='nw')
    
    # Variables for form inputs
    contrast_verification = ttk.Entry(frame)
    description = Text(frame, height=5, width=50)
    vapt_statuses = {cat: ttk.Combobox(frame, values=['Found', 'Not Found', 'NA'], state='readonly') for cat in VAPT_CATEGORIES}
    vapt_comments = {cat: ttk.Entry(frame) for cat in VAPT_CATEGORIES}
    
    # Summary Section
    ttk.Label(frame, text="Summary", font=("Helvetica", 12, "bold")).pack(anchor='w', pady=5)
    ttk.Label(frame, text="Contrast Verification:").pack(anchor='w')
    contrast_verification.pack(fill='x', pady=5)
    ttk.Label(frame, text="Description:").pack(anchor='w')
    description.pack(fill='x', pady=5)
    
    # Security Analysis Section
    ttk.Label(frame, text="Security Analysis", font=("Helvetica", 12, "bold")).pack(anchor='w', pady=10)
    
    # VAPT Table
    table_frame = ttk.Frame(frame)
    table_frame.pack(fill='x', pady=5)
    
    ttk.Label(table_frame, text="Sr. No.", font=("Helvetica", 10, "bold")).grid(row=0, column=0, padx=5, pady=5)
    ttk.Label(table_frame, text="Category", font=("Helvetica", 10, "bold")).grid(row=0, column=1, padx=5, pady=5)
    ttk.Label(table_frame, text="Status", font=("Helvetica", 10, "bold")).grid(row=0, column=2, padx=5, pady=5)
    ttk.Label(table_frame, text="Comment", font=("Helvetica", 10, "bold")).grid(row=0, column=3, padx=5, pady=5)
    
    for i, category in enumerate(VAPT_CATEGORIES, 1):
        ttk.Label(table_frame, text=str(i)).grid(row=i, column=0, padx=5, pady=5)
        ttk.Label(table_frame, text=category).grid(row=i, column=1, padx=5, pady=5, sticky='w')
        vapt_statuses[category].grid(row=i, column=2, padx=5, pady=5)
        vapt_statuses[category].set('NA')
        vapt_comments[category].grid(row=i, column=3, padx=5, pady=5, sticky='ew')
    
    # Save and Generate Report Button
    ttk.Button(frame, text="Save and Generate Report", command=lambda: save_and_generate()).pack(pady=10)
    
    # Update canvas scroll region
    def configure_canvas(event=None):
        canvas.configure(scrollregion=canvas.bbox("all"))
    
    frame.bind('<Configure>', configure_canvas)
    canvas.configure(yscrollcommand=scrollbar.set)
    
    # Ensure the canvas resizes with the window
    def on_frame_configure(event=None):
        canvas.itemconfig(canvas_frame, width=canvas.winfo_width())
    
    canvas.bind('<Configure>', on_frame_configure)
    
    # Save and Generate Report
    def save_and_generate():
        report_data = {
            'version': version,
            'contrast_verification': contrast_verification.get(),
            'description': description.get("1.0", END).strip(),
            'vapt_analysis': {cat: {'status': vapt_statuses[cat].get(), 'comment': vapt_comments[cat].get()} for cat in VAPT_CATEGORIES}
        }
        
 â€œ

System: It appears that the response was cut off, likely due to exceeding the maximum token limit. I'll provide a complete and concise fix for the `generate_html_report` function to ensure the UI displays all required elements (Contrast Verification, Description, 20 VAPT categories with dropdowns and comment entries, and the "Save and Generate Report" button) while retaining the previous fixes for file naming (`{version}.html`, `{version}.json`) and the f-string syntax error. I'll also ensure the rest of the script remains functional.

### Fix for `generate_html_report`
The issue with the incomplete UI is likely due to improper layout management in the `generate_html_report` function, particularly with the scrollable VAPT table. The previous script used a `Canvas` with a `Frame`, but the configuration may not have properly handled the scrollable area or widget visibility. I'll:
- Use a `Canvas` with a `Frame` for the entire form to ensure all elements (Summary section, Security Analysis table, and button) are scrollable and visible.
- Ensure the VAPT table displays all 20 categories with `Sr. No.`, `Category`, `Status` (dropdown), and `Comment` (entry).
- Place the "Save and Generate Report" button at the bottom of the form.
- Increase the window size to better accommodate the content.
- Retain the f-string fix by using `Formatted Comments`.
- Maintain file outputs as `{version}.html` and `{version}.json`.

### Corrected `generate_html_report` Function
Below is the corrected `generate_html_report` function, which replaces the one in the previous script. The rest of the script (including imports, other functions, and GUI setup) remains unchanged unless specified.

```python
def generate_html_report(version, df):
    """Show a form to generate the HTML report with all fields and scrollable VAPT table."""
    report_window = Toplevel(root)
    report_window.title(f"Generate {version} Build Report")
    report_window.geometry("900x700")  # Increased size for better visibility
    
    # Main frame with scrollable canvas
    main_frame = ttk.Frame(report_window)
    main_frame.pack(fill='both', expand=True)
    
    canvas = Canvas(main_frame)
    canvas.pack(side='left', fill='both', expand=True)
    
    scrollbar = ttk.Scrollbar(main_frame, orient='vertical', command=canvas.yview)
    scrollbar.pack(side='right', fill='y')
    
    frame = ttk.Frame(canvas)
    canvas_frame = canvas.create_window((0, 0), window=frame, anchor='nw')
    
    # Configure canvas scrolling
    def configure_canvas(event=None):
        canvas.configure(scrollregion=canvas.bbox("all"))
    
    frame.bind('<Configure>', configure_canvas)
    canvas.configure(yscrollcommand=scrollbar.set)
    
    # Ensure canvas resizes with window
    def on_frame_configure(event=None):
        canvas.itemconfig(canvas_frame, width=canvas.winfo_width())
    
    canvas.bind('<Configure>', on_frame_configure)
    
    # Variables for form inputs
    contrast_verification = ttk.Entry(frame, width=50)
    description = Text(frame, height=5, width=50)
    vapt_statuses = {cat: ttk.Combobox(frame, values=['Found', 'Not Found', 'NA'], state='readonly', width=15) for cat in VAPT_CATEGORIES}
    vapt_comments = {cat: ttk.Entry(frame, width=30) for cat in VAPT_CATEGORIES}
    
    # Summary Section
    ttk.Label(frame, text="Summary", font=("Helvetica", 12, "bold")).pack(anchor='w', pady=10)
    ttk.Label(frame, text="Contrast Verification:").pack(anchor='w', padx=5)
    contrast_verification.pack(fill='x', padx=5, pady=5)
    ttk.Label(frame, text="Description:").pack(anchor='w', padx=5)
    description.pack(fill='x', padx=5, pady=5)
    
    # Security Analysis Section
    ttk.Label(frame, text="Security Analysis", font=("Helvetica", 12, "bold")).pack(anchor='w', pady=10)
    
    # VAPT Table
    table_frame = ttk.Frame(frame)
    table_frame.pack(fill='x', padx=5, pady=5)
    
    ttk.Label(table_frame, text="Sr. No.", font=("Helvetica", 10, "bold")).grid(row=0, column=0, padx=5, pady=5, sticky='w')
    ttk.Label(table_frame, text="Category", font=("Helvetica", 10, "bold")).grid(row=0, column=1, padx=5, pady=5, sticky='w')
    ttk.Label(table_frame, text="Status", font=("Helvetica", 10, "bold")).grid(row=0, column=2, padx=5, pady=5, sticky='w')
    ttk.Label(table_frame, text="Comment", font=("Helvetica", 10, "bold")).grid(row=0, column=3, padx=5, pady=5, sticky='w')
    
    for i, category in enumerate(VAPT_CATEGORIES, 1):
        ttk.Label(table_frame, text=str(i)).grid(row=i, column=0, padx=5, pady=2, sticky='w')
        ttk.Label(table_frame, text=category).grid(row=i, column=1, padx=5, pady=2, sticky='w')
        vapt_statuses[category].grid(row=i, column=2, padx=5, pady=2)
        vapt_statuses[category].set('NA')
        vapt_comments[category].grid(row=i, column=3, padx=5, pady=2, sticky='ew')
    
    table_frame.columnconfigure(3, weight=1)  # Make Comment column expandable
    
    # Save and Generate Report Button
    ttk.Button(frame, text="Save and Generate Report", command=lambda: save_and_generate()).pack(pady=15)
    
    # Save and Generate Report Logic
    def save_and_generate():
        report_data = {
            'version': version,
            'contrast_verification': contrast_verification.get(),
            'description': description.get("1.0", END).strip(),
            'vapt_analysis': {cat: {'status': vapt_statuses[cat].get(), 'comment': vapt_comments[cat].get()} for cat in VAPT_CATEGORIES}
        }
        
        # Save to JSON
        json_filename = os.path.join(current_dir, f"{version}.json")
        while True:
            try:
                with open(json_filename, 'w', encoding='utf-8') as f:
                    json.dump(report_data, f, indent=2)
                text.insert(END, f"Saved report data to {json_filename}\n")
                break
            except PermissionError as e:
                text.insert(END, f"Error saving {json_filename}: {str(e)}\n")
                if not show_retry_dialog(root, f"Cannot write {json_filename}: {str(e)}. Retry or stop?"):
                    text.insert(END, "Stopping report save.\n")
                    report_window.destroy()
                    return
        
        # Preprocess comments to avoid f-string backslash issue
        df['Formatted Comments'] = df['Filtered Comments'].apply(
            lambda x: x.replace('\n', '<br>') if pd.notna(x) else ''
        )
        
        # Generate HTML
        html_content = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{version} Build Report</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            background-color: #f4f4f4;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #2c3e50;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: none;
        }
        .section {
            margin-bottom: 40px;
        }
        .container {
            max-width: 1200px;
            margin: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>{version} Build Report</h1>
        
        <div class="section">
            <h2>Summary</h2>
            <table>
                <tr>
                    <th>Build</th>
                    <th>Date</th>
                    <th colspan="2">Total Changelog</th>
                    <th>Contrast Verification</th>
                </tr>
                <tr>
                    <th></th>
                    <th></th>
                    <th>Functional Jira</th>
                    <th>Security Jira</th>
                    <th></th>
                </tr>
                <tr>
                    <td>{version}</td>
                    <td>{datetime.now().strftime('%d-%b-%Y')}</td>
                    <td>{len(df[df['Test Approach'] == 'Functional Jira'])}</td>
                    <td>{len(df[df['Test Approach'] == 'Security Jira'])}</td>
                    <td>{report_data['contrast_verification']}</td>
                </tr>
            </table>
            <h3>Description</h3>
            <textarea readonly>{report_data['description']}</textarea>
        </div>
        
        <div class="section">
            <h2>Security Analysis</h2>
            <table>
                <tr>
                    <th>Sr. No.</th>
                    <th>Category</th>
                    <th>Status</th>
                    <th>Comment</th>
                </tr>
"""
        for i, cat in enumerate(VAPT_CATEGORIES, 1):
            html_content += f"""
                <tr>
                    <td>{i}</td>
                    <td>{cat}</td>
                    <td>{report_data['vapt_analysis'][cat]['status']}</td>
                    <td>{report_data['vapt_analysis'][cat]['comment']}</td>
                </tr>
"""
        html_content += """
            </table>
        </div>
        
        <div class="section">
            <h2>Build Table</h2>
            <table>
                <tr>
                    <th>Build</th>
                    <th>Date</th>
                    <th>Total no of Jiras</th>
                </tr>
                <tr>
                    <td>{version}</td>
                    <td>{datetime.now().strftime('%d-%b-%Y')}</td>
                    <td>{len(df)}</td>
                </tr>
            </table>
            
            <h3>Changelog Details</h3>
            <table>
                <tr>
                    <th>Changelog Reviewer</th>
                    <th>Issue key</th>
                    <th>Test Approach</th>
                    <th>Manual Code Review</th>
                    <th>Manual Security Testing</th>
                    <th>Remark/Comment</th>
                </tr>
"""
        for _, row in df.iterrows():
            html_content += f"""
                <tr>
                    <td>{row['Changelog Reviewer']}</td>
                    <td>{row['Issue key']}</td>
                    <td>{row['Test Approach']}</td>
                    <td>{row['Manual Secure Code Review']}</td>
                    <td>{row['Manual Security Testing']}</td>
                    <td>{row['Formatted Comments']}</td>
                </tr>
"""
        html_content += """
            </table>
        </div>
    </div>
</body>
</html>
"""
        
        # Save HTML
        html_filename = os.path.join(current_dir, f"{version}.html")
        while True:
            try:
                with open(html_filename, 'w', encoding='utf-8') as f:
                    f.write(html_content)
                text.insert(END, f"Generated HTML report: {html_filename}\n")
                webbrowser.open(f"file://{os.path.abspath(html_filename)}")
                break
            except PermissionError as e:
                text.insert(END, f"Error saving {html_filename}: {str(e)}\n")
                if not show_retry_dialog(root, f"Cannot write {html_filename}: {str(e)}. Retry or stop?"):
                    text.insert(END, "Stopping HTML report generation.\n")
                    report_window.destroy()
                    return
        report_window.destroy()
    
    # Center the window
    report_window.update_idletasks()
    x = root.winfo_x() + (root.winfo_width() - report_window.winfo_width()) // 2
    y = root.winfo_y() + (root.winfo_height() - report_window.winfo_height()) // 2
    report_window.geometry(f"+{x}+{y}")
    report_window.resizable(False, False)