import os
import json
import time
import requests
import pandas as pd
from tkinter import Tk, ttk, Text, Scrollbar, END, messagebox

# Get the current directory of the script
current_dir = os.path.dirname(os.path.abspath(__file__))

# Path for token file and debug file
TOKEN_FILE = os.path.join(current_dir, 'token.json')
DEBUG_FILE = os.path.join(current_dir, 'response_debug.txt')

# Batch size for fetching issues
BATCH_SIZE = 100

def save_token():
    """Save or update the entered token to token.json and hide the file."""
    token = entry_api_token.get().strip()
    if not token or token == '*******':
        messagebox.showerror("Error", "Please enter a valid API token.")
        return
    try:
        # Check if directory is writable
        if not os.access(current_dir, os.W_OK):
            raise PermissionError(f"No write permission for directory: {current_dir}")
        
        with open(TOKEN_FILE, 'w') as token_file:
            json.dump({'token': token}, token_file, indent=2)
        # Hide the token file (Windows-specific)
        os.system(f'attrib +h "{TOKEN_FILE}"')
        entry_api_token.delete(0, END)
        entry_api_token.insert(0, '*******')  # Mask token after saving
        text.insert(END, "Token saved/updated successfully.\n")
        text.see(END)
    except PermissionError as e:
        messagebox.showerror("Error", f"Failed to save token: {str(e)}")
        text.insert(END, f"Error saving token: {str(e)}\n")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save token: {str(e)}")
        text.insert(END, f"Error saving token: {str(e)}\n")

def load_token():
    """Load the token from token.json if it exists."""
    if os.path.exists(TOKEN_FILE):
        try:
            # Check if file is readable
            if not os.access(TOKEN_FILE, os.R_OK):
                raise PermissionError(f"No read permission for file: {TOKEN_FILE}")
            
            with open(TOKEN_FILE, 'r') as token_file:
                data = json.load(token_file)
                token = data.get('token', '')
                if not token:
                    raise ValueError("Token field is empty in token.json")
                return token
        except json.JSONDecodeError as e:
            text.insert(END, f"Error reading token.json: Invalid JSON format - {str(e)}\n")
            return ''
        except PermissionError as e:
            text.insert(END, f"Error reading token.json: {str(e)}\n")
            return ''
        except Exception as e:
            text.insert(END, f"Error reading token.json: {str(e)}\n")
            return ''
    return ''

def flatten_dict(d, parent_key='', sep='.'):
    """Flatten a nested dictionary into a flat dictionary with concatenated keys."""
    items = []
    for key, value in d.items():
        new_key = f"{parent_key}{sep}{key}" if parent_key else key
        if isinstance(value, dict):
            items.extend(flatten_dict(value, new_key, sep).items())
        elif isinstance(value, list):
            for i, item in enumerate(value):
                if isinstance(item, dict):
                    items.extend(flatten_dict(item, f"{new_key}[{i}]", sep).items())
                else:
                    items.append((f"{new_key}[{i}]", str(item)))
        else:
            items.append((new_key, str(value) if value is not None else ''))
    return dict(items)

def fetch_data():
    token = entry_api_token.get().strip()
    version = entry_version.get().strip()
    
    # If token is masked, try to load the actual token from file
    if token == '*******':
        token = load_token()
        if not token:
            messagebox.showerror("Error", "No saved token found. Please enter and save a valid token.")
            return
    
    if not token or not version:
        messagebox.showerror("Error", "Please fill in all fields.")
        return
    
    text.delete(1.0, END)
    text.insert(END, "Starting data fetch...\n")
    
    # Form the R version
    r_version = version
    if version.lower().startswith('v'):
        r_version = 'R' + version[1:]
    else:
        r_version = 'R' + version
    
    # Form JQL
    jql = f'"Build(s)" in ({version}) OR "Build(s)" in ({r_version})'
    
    text.insert(END, f"Formed JQL: {jql}\n")
    
    try:
        # Prepare authentication header (Bearer token)
        headers = {
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json'
        }
        
        # Jira REST API endpoint
        url = 'https://jira.crm.com/rest/api/3/search'
        
        data = []
        all_fields = set()
        start_at = 0
        total_issues = 0
        
        while True:
            text.insert(END, f"Fetching issues {start_at + 1} to {start_at + BATCH_SIZE}...\n")
            payload = {
                'jql': jql,
                'startAt': start_at,
                'maxResults': BATCH_SIZE,
                'fields': ['*all']  # Fetch all fields
            }
            
            try:
                response = requests.post(url, headers=headers, json=payload)
                text.insert(END, f"API Response Status: {response.status_code}\n")
                
                # Save raw response to debug file
                with open(DEBUG_FILE, 'w', encoding='utf-8') as debug_file:
                    debug_file.write(response.text)
                text.insert(END, f"Raw response saved to: {DEBUG_FILE}\n")
                
                if response.status_code != 200:
                    text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
                    response.raise_for_status()
                
                try:
                    result = response.json()
                except json.JSONDecodeError as e:
                    text.insert(END, f"JSON Parse Error: {str(e)}\n")
                    text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
                    messagebox.showerror("Error", f"Failed to parse JSON response: {str(e)}")
                    return
                
                issues = result.get('issues', [])
                
                if not issues:
                    break
                
                total_issues += len(issues)
                text.insert(END, f"Fetched {len(issues)} issues in this batch. Total so far: {total_issues}\n")
                
                # Process issues in the batch
                for issue in issues:
                    # Flatten the fields dictionary
                    flattened_issue = flatten_dict(issue['fields'])
                    flattened_issue['key'] = issue['key']  # Always include issue key
                    data.append(flattened_issue)
                    # Update set of all fields
                    all_fields.update(flattened_issue.keys())
                
                start_at += BATCH_SIZE
                text.see(END)  # Scroll to the latest console output
                root.update()  # Update GUI to keep it responsive
                
                # Add 15-second delay between batch requests
                if issues:  # Only delay if more issues are expected
                    text.insert(END, "Waiting 15 seconds before next batch...\n")
                    text.see(END)
                    time.sleep(15)
            
            except requests.exceptions.RequestException as e:
                text.insert(END, f"API Request Error: {str(e)}\n")
                if 'response' in locals():
                    text.insert(END, f"Status Code: {response.status_code}\n")
                    text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
                    text.insert(END, f"Raw response saved to: {DEBUG_FILE}\n")
                messagebox.showerror("Error", f"API Request Failed: {str(e)}")
                return
        
        text.insert(END, f"Total issues fetched: {total_issues}\n")
        
        if data:
            # Create DataFrame with all fields
            df = pd.DataFrame(data)
            # Ensure all fields are present in DataFrame, filling missing values with empty strings
            for field in all_fields:
                if field not in df.columns:
                    df[field] = ''
            # Reorder columns to have 'key' first
            cols = ['key'] + [col for col in df.columns if col != 'key']
            df = df[cols]
            
            filename = os.path.join(current_dir, f"{version}_data.xlsx")
            text.insert(END, f"Exporting to {filename}...\n")
            # Overwrite the file if it exists
            df.to_excel(filename, index=False, engine='openpyxl')
            text.insert(END, "Export complete.\n")
        else:
            text.insert(END, "No data to export.\n")
    
    except Exception as e:
        messagebox.showerror("Error", str(e))
        text.insert(END, f"Error: {str(e)}\n")

# Create GUI
root = Tk()
root.title("Jira Report Generator")
root.geometry("600x400")

# Use ttk for smoother look
style = ttk.Style()
style.theme_use('clam')  # A smoother theme
style.configure('TButton', padding=6)
style.configure('TEntry', padding=5)
style.configure('TLabel', padding=3)

frame = ttk.Frame(root, padding="10")
frame.pack(fill='both', expand=True)

# API Token
ttk.Label(frame, text="Jira API Token:").grid(row=0, column=0, sticky='w', pady=5)
entry_api_token = ttk.Entry(frame, width=50, show='*')
entry_api_token.grid(row=0, column=1, pady=5)

# Load token if it exists
try:
    saved_token = load_token()
    if saved_token:
        entry_api_token.insert(0, '*******')  # Mask token in GUI
except Exception as e:
    text = Text(frame, wrap='word', height=10, borderwidth=2, relief='flat')
    text.insert(END, f"Error loading token: {str(e)}\n")
    text.grid(row=5, column=0, columnspan=2, sticky='nsew')

# Save Token Button
btn_save_token = ttk.Button(frame, text="Save/Update Token", command=save_token)
btn_save_token.grid(row=1, column=0, columnspan=2, pady=5)

# Version
ttk.Label(frame, text="Version (e.g., v12.6.3.9999900):").grid(row=2, column=0, sticky='w', pady=5)
entry_version = ttk.Entry(frame, width=50)
entry_version.grid(row=2, column=1, pady=5)

# Fetch Button
btn_fetch = ttk.Button(frame, text="Fetch and Export Data", command=fetch_data)
btn_fetch.grid(row=3, column=0, columnspan=2, pady=10)

# Console-like text area
ttk.Label(frame, text="Console:").grid(row=4, column=0, sticky='w', pady=5)
text_frame = ttk.Frame(frame)
text_frame.grid(row=5, column=0, columnspan=2, sticky='nsew')

text = Text(text_frame, wrap='word', height=10, borderwidth=2, relief='flat')
text.pack(side='left', fill='both', expand=True)

scrollbar = Scrollbar(text_frame, command=text.yview)
scrollbar.pack(side='right', fill='y')
text.config(yscrollcommand=scrollbar.set)

# Make the text area expand
frame.rowconfigure(5, weight=1)
frame.columnconfigure(1, weight=1)

# Smooth edges for the window
root.resizable(False, False)
root.configure(bg='#f0f0f0')

root.mainloop()