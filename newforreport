import os
import json
import time
import requests
import pandas as pd
from tkinter import Tk, ttk, Text, Scrollbar, END, messagebox
import base64
import io

# Get the current directory of the script
current_dir = os.path.dirname(os.path.abspath(__file__))

# Path for token file and debug file
TOKEN_FILE = os.path.join(current_dir, 'token.json')
DEBUG_FILE = os.path.join(current_dir, 'response_debug.txt')
USERNAME_FILE = os.path.join(current_dir, 'username.xlsx')

# Hardcoded usernames (replace placeholders user1-user20 with actual usernames)
USERNAMES = [
    'sam.tam', 'din.time', 'jh.jk',
    'user1', 'user2', 'user3', 'user4', 'user5',
    'user6', 'user7', 'user8', 'user9', 'user10',
    'user11', 'user12', 'user13', 'user14', 'user15',
    'user16', 'user17', 'user18', 'user19', 'user20'
]

def create_username_file():
    """Create username.xlsx with hardcoded usernames in the current directory."""
    try:
        text.insert(END, f"Creating username.xlsx...\n")
        # Check if directory is writable
        if not os.access(current_dir, os.W_OK):
            raise PermissionError(f"No write permission for directory: {current_dir}")
        
        # Create DataFrame with usernames
        df = pd.DataFrame({'Username': USERNAMES})
        
        # Attempt to write the file, handle if it's open
        while True:
            try:
                df.to_excel(USERNAME_FILE, index=False, engine='openpyxl')
                text.insert(END, f"Saved username.xlsx to {USERNAME_FILE}\n")
                text.see(END)
                break
            except PermissionError:
                text.insert(END, f"Error: {USERNAME_FILE} is open. Please close the file and try again.\n")
                messagebox.showwarning("File Open", f"Please close {USERNAME_FILE} and click OK to retry.")
                time.sleep(5)  # Wait 5 seconds before retrying
    
    except PermissionError as e:
        text.insert(END, f"Error creating username.xlsx: {str(e)}\n")
        messagebox.showerror("Error", f"Failed to create username.xlsx: {str(e)}")
    except Exception as e:
        text.insert(END, f"Error creating username.xlsx: {str(e)}\n")
        messagebox.showerror("Error", f"Failed to create username.xlsx: {str(e)}")

def save_token():
    """Save or update the entered token to token.json and hide the file."""
    token = entry_api_token.get().strip()
    if not token or token == '*******':
        messagebox.showerror("Error", "Please enter a valid API token.")
        return
    try:
        # Check if directory is writable
        if not os.access(current_dir, os.W_OK):
            raise PermissionError(f"No write permission for directory: {current_dir}")
        
        with open(TOKEN_FILE, 'w') as token_file:
            json.dump({'token': token}, token_file, indent=2)
        # Hide the token file (Windows-specific)
        os.system(f'attrib +h "{TOKEN_FILE}"')
        entry_api_token.delete(0, END)
        entry_api_token.insert(0, '*******')  # Mask token after saving
        text.insert(END, "Token saved/updated successfully.\n")
        text.see(END)
        update_token_status()
    except PermissionError as e:
        messagebox.showerror("Error", f"Failed to save token: {str(e)}")
        text.insert(END, f"Error saving token: {str(e)}\n")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save token: {str(e)}")
        text.insert(END, f"Error saving token: {str(e)}\n")

def load_token():
    """Load the token from token.json if it exists."""
    if os.path.exists(TOKEN_FILE):
        try:
            # Check if file is readable
            if not os.access(TOKEN_FILE, os.R_OK):
                raise PermissionError(f"No read permission for file: {TOKEN_FILE}")
            
            with open(TOKEN_FILE, 'r') as token_file:
                data = json.load(token_file)
                token = data.get('token', '')
                if not token:
                    raise ValueError("Token field is empty in token.json")
                return token
        except json.JSONDecodeError as e:
            text.insert(END, f"Error reading token.json: Invalid JSON format - {str(e)}\n")
            return ''
        except PermissionError as e:
            text.insert(END, f"Error reading token.json: {str(e)}\n")
            return ''
        except Exception as e:
            text.insert(END, f"Error reading token.json: {str(e)}\n")
            return ''
    return ''

def update_token_status():
    """Update the token status label color and text."""
    token = entry_api_token.get().strip()
    if token == '*******' or token:
        token_status_label.config(text="Token present", foreground="green")
    else:
        token_status_label.config(text="Token blank", foreground="red")

def fetch_data():
    # Disable buttons during execution
    btn_save_token.config(state='disabled')
    btn_fetch.config(state='disabled')
    
    token = entry_api_token.get().strip()
    version = entry_version.get().strip()
    
    # If token is masked, try to load the actual token from file
    if token == '*******':
        token = load_token()
        if not token:
            messagebox.showerror("Error", "No saved token found. Please enter and save a valid token.")
            # Re-enable buttons
            btn_save_token.config(state='normal')
            btn_fetch.config(state='normal')
            return
    
    if not token or not version:
        messagebox.showerror("Error", "Please fill in all fields.")
        # Re-enable buttons
        btn_save_token.config(state='normal')
        btn_fetch.config(state='normal')
        return
    
    # Create username.xlsx with hardcoded usernames
    create_username_file()
    
    text.insert(END, "Starting Jira data fetch...\n")
    
    # Form the R version
    r_version = version
    if version.lower().startswith('v'):
        r_version = 'R' + version[1:]
    else:
        r_version = 'R' + version
    
    # Form JQL
    jql = f'"Build(s)" in ({version}) OR "Build(s)" in ({r_version})'
    
    text.insert(END, f"Formed JQL: {jql}\n")
    
    try:
        # Try Bearer token authentication
        headers_bearer = {
            'Authorization': f'Bearer {token}',
            'Accept': 'text/csv'
        }
        
        # CSV export endpoint
        url = f'https://jira.crm.com/sr/jira.issueviews:searchrequest-csv-all-fields/temp/SearchRequest.csv?jqlQuery={jql}'
        
        text.insert(END, "Attempting fetch with Bearer token...\n")
        response = requests.get(url, headers=headers_bearer)
        text.insert(END, f"API Response Status (Bearer): {response.status_code}\n")
        
        # Save raw response to debug file
        with open(DEBUG_FILE, 'w', encoding='utf-8') as debug_file:
            debug_file.write(response.text)
        text.insert(END, f"Raw response saved to: {DEBUG_FILE}\n")
        
        if response.status_code != 200:
            # Try Basic Auth as a fallback
            text.insert(END, "Bearer token failed, attempting Basic Auth...\n")
            # Replace 'user@example.com' with your Jira email
            auth_string = f"user@example.com:{token}"
            auth_bytes = auth_string.encode('ascii')
            auth_base64 = base64.b64encode(auth_bytes).decode('ascii')
            headers_basic = {
                'Authorization': f'Basic {auth_base64}',
                'Accept': 'text/csv'
            }
            
            response = requests.get(url, headers=headers_basic)
            text.insert(END, f"API Response Status (Basic): {response.status_code}\n")
            
            # Save raw response to debug file
            with open(DEBUG_FILE, 'w', encoding='utf-8') as debug_file:
                debug_file.write(response.text)
            text.insert(END, f"Raw response saved to: {DEBUG_FILE}\n")
            
            if response.status_code != 200:
                text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
                response.raise_for_status()
        
        # Parse CSV response
        try:
            df = pd.read_csv(io.StringIO(response.text))
            text.insert(END, f"Fetched {len(df)} issues.\n")
        except pd.errors.ParserError as e:
            text.insert(END, f"CSV Parse Error: {str(e)}\n")
            text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
            messagebox.showerror("Error", f"Failed to parse CSV response: {str(e)}")
            # Re-enable buttons
            btn_save_token.config(state='normal')
            btn_fetch.config(state='normal')
            # Delete debug file
            if os.path.exists(DEBUG_FILE):
                os.remove(DEBUG_FILE)
            return
        
        text.insert(END, f"Total issues fetched: {len(df)}\n")
        
        if not df.empty:
            # Save to temporary Excel to process
            temp_filename = os.path.join(current_dir, f"temp_{version}_data.xlsx")
            df.to_excel(temp_filename, index=False, engine='openpyxl')
            
            # Load back for processing
            df = pd.read_excel(temp_filename)
            
            # Step 1: Delete columns except Issue key, Issue Type, Status, Component/s*, Comment*
            columns_to_keep = [col for col in df.columns if col in ['Issue key', 'Issue Type', 'Status'] or col.startswith('Component/s') or col.startswith('Comment')]
            df = df[columns_to_keep]
            
            # Step 2: Add Test Approach column
            df['Test Approach'] = 'Functional Jira'
            component_columns = [col for col in df.columns if col.startswith('Component/s')]
            for col in component_columns:
                df.loc[df[col].str.contains('Security|AppSecurity', na=False, case=False), 'Test Approach'] = 'Security Jira'
            
            # Delete component columns
            df = df.drop(columns=component_columns)
            
            # Step 3: Load usernames from username.xlsx
            if os.path.exists(USERNAME_FILE):
                usernames_df = pd.read_excel(USERNAME_FILE)
                usernames = usernames_df['Username'].str.lower().tolist()
            else:
                usernames = []
                text.insert(END, "Warning: username.xlsx not found. Skipping comment filtering.\n")
            
            # Filter and append comments to a single column
            comment_columns = [col for col in df.columns if col.startswith('Comment')]
            df['Filtered Comments'] = ''
            
            for index, row in df.iterrows():
                filtered_comments = []
                for col in comment_columns:
                    comment = str(row[col]) if pd.notna(row[col]) else ''
                    if comment:
                        # Check if comment contains any username and the version
                        comment_lower = comment.lower()
                        username_match = any(username in comment_lower for username in usernames)
                        version_match = version.lower() in comment_lower
                        if username_match and version_match:
                            filtered_comments.append(comment)
                        else:
                            df.at[index, col] = ''  # Erase non-matching comments
                df.at[index, 'Filtered Comments'] = '\n\n'.join(filtered_comments)
            
            # Delete original comment columns
            df = df.drop(columns=comment_columns)
            
            # Save the processed DataFrame, handle if file is open
            filename = os.path.join(current_dir, f"{version}_data.xlsx")
            text.insert(END, f"Exporting processed data to {filename}...\n")
            while True:
                try:
                    df.to_excel(filename, index=False, engine='openpyxl')
                    text.insert(END, "Export complete.\n")
                    text.see(END)
                    break
                except PermissionError:
                    text.insert(END, f"Error: {filename} is open. Please close the file and try again.\n")
                    messagebox.showwarning("File Open", f"Please close {filename} and click OK to retry.")
                    time.sleep(5)  # Wait 5 seconds before retrying
            
            # Delete temporary file
            if os.path.exists(temp_filename):
                os.remove(temp_filename)
        else:
            text.insert(END, "No data to export.\n")
    
    except requests.exceptions.RequestException as e:
        text.insert(END, f"API Request Error: {str(e)}\n")
        if 'response' in locals():
            text.insert(END, f"Status Code: {response.status_code}\n")
            text.insert(END, f"Raw Response: {response.text[:1000]}...\n")
            text.insert(END, f"Raw response saved to: {DEBUG_FILE}\n")
        messagebox.showerror("Error", f"API Request Failed: {str(e)}")
    
    except Exception as e:
        messagebox.showerror("Error", str(e))
        text.insert(END, f"Error: {str(e)}\n")
    
    finally:
        # Re-enable buttons
        btn_save_token.config(state='normal')
        btn_fetch.config(state='normal')
        # Delete debug file
        if os.path.exists(DEBUG_FILE):
            os.remove(DEBUG_FILE)

# Create GUI
root = Tk()
root.title("Jira Report Generator")
root.geometry("600x400")

# Use ttk for smoother look
style = ttk.Style()
style.theme_use('clam')  # A smoother theme
style.configure('TButton', padding=6)
style.configure('TEntry', padding=5)
style.configure('TLabel', padding=3)

frame = ttk.Frame(root, padding="10")
frame.pack(fill='both', expand=True)

# API Token
ttk.Label(frame, text="Jira API Token:").grid(row=0, column=0, sticky='w', pady=5)
entry_api_token = ttk.Entry(frame, width=50, show='*')
entry_api_token.grid(row=0, column=1, pady=5)

# Token status label
token_status_label = ttk.Label(frame, text="Token blank", foreground="red")
token_status_label.grid(row=1, column=1, sticky='w', pady=5)

# Load token if it exists
try:
    saved_token = load_token()
    if saved_token:
        entry_api_token.insert(0, '*******')  # Mask token in GUI
        update_token_status()
except Exception as e:
    text = Text(frame, wrap='word', height=10, borderwidth=2, relief='flat')
    text.insert(END, f"Error loading token: {str(e)}\n")
    text.grid(row=6, column=0, columnspan=2, sticky='nsew')

# Save Token Button
btn_save_token = ttk.Button(frame, text="Save/Update Token", command=save_token)
btn_save_token.grid(row=2, column=0, columnspan=2, pady=5)

# Version
ttk.Label(frame, text="Version (e.g., v12.6.3.9999900):").grid(row=3, column=0, sticky='w', pady=5)
entry_version = ttk.Entry(frame, width=50)
entry_version.grid(row=3, column=1, pady=5)

# Fetch Button
btn_fetch = ttk.Button(frame, text="Fetch and Export Data", command=fetch_data)
btn_fetch.grid(row=4, column=0, columnspan=2, pady=10)

# Console-like text area
ttk.Label(frame, text="Console:").grid(row=5, column=0, sticky='w', pady=5)
text_frame = ttk.Frame(frame)
text_frame.grid(row=6, column=0, columnspan=2, sticky='nsew')

text = Text(text_frame, wrap='word', height=10, borderwidth=2, relief='flat')
text.pack(side='left', fill='both', expand=True)

scrollbar = Scrollbar(text_frame, command=text.yview)
scrollbar.pack(side='right', fill='y')
text.config(yscrollcommand=scrollbar.set)

# Make the text area expand
frame.rowconfigure(6, weight=1)
frame.columnconfigure(1, weight=1)

# Smooth edges for the window
root.resizable(False, False)
root.configure(bg='#f0f0f0')

root.mainloop()