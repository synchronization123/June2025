import os
import json
import time
import requests
import pandas as pd
from tkinter import Tk, ttk, Text, Scrollbar, END, messagebox

# Get the current directory of the script
current_dir = os.path.dirname(os.path.abspath(__file__))

# Path for token file
TOKEN_FILE = os.path.join(current_dir, 'token.json')

# Batch size for fetching issues
BATCH_SIZE = 100

def save_token():
    """Save or update the entered token to token.json and hide the file."""
    token = entry_api_token.get().strip()
    if not token or token == '*******':
        messagebox.showerror("Error", "Please enter a valid API token.")
        return
    try:
        with open(TOKEN_FILE, 'w') as token_file:
            json.dump({'token': token}, token_file)
        # Hide the token file (Windows-specific)
        os.system(f'attrib +h "{TOKEN_FILE}"')
        entry_api_token.delete(0, END)
        entry_api_token.insert(0, '*******')  # Mask token after saving
        text.insert(END, "Token saved/updated successfully.\n")
        text.see(END)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save token: {str(e)}")
        text.insert(END, f"Error saving token: {str(e)}\n")

def load_token():
    """Load the token from token.json if it exists."""
    if os.path.exists(TOKEN_FILE):
        try:
            with open(TOKEN_FILE, 'r') as token_file:
                data = json.load(token_file)
                return data.get('token', '')
        except Exception as e:
            text.insert(END, f"Error loading token: {str(e)}\n")
            return ''
    return ''

def fetch_data():
    token = entry_api_token.get().strip()
    version = entry_version.get().strip()
    
    # If token is masked, try to load the actual token from file
    if token == '*******':
        token = load_token()
        if not token:
            messagebox.showerror("Error", "No saved token found. Please enter and save a valid token.")
            return
    
    if not token or not version:
        messagebox.showerror("Error", "Please fill in all fields.")
        return
    
    text.delete(1.0, END)
    text.insert(END, "Starting data fetch...\n")
    
    # Form the R version
    r_version = version
    if version.lower().startswith('v'):
        r_version = 'R' + version[1:]
    else:
        r_version = 'R' + version
    
    # Form JQL
    jql = f'"Build(s)" in ({version}) OR "Build(s)" in ({r_version})'
    
    text.insert(END, f"Formed JQL: {jql}\n")
    
    try:
        # Prepare authentication header (Bearer token)
        headers = {
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json'
        }
        
        # Jira REST API endpoint
        url = 'https://jira.crm.com/rest/api/3/search'
        
        data = []
        max_comments = 0
        max_components = 0
        start_at = 0
        total_issues = 0
        
        while True:
            text.insert(END, f"Fetching issues {start_at + 1} to {start_at + BATCH_SIZE}...\n")
            payload = {
                'jql': jql,
                'startAt': start_at,
                'maxResults': BATCH_SIZE,
                'fields': ['key', 'status', 'components', 'comment']
            }
            
            try:
                response = requests.post(url, headers=headers, json=payload)
                text.insert(END, f"API Response Status: {response.status_code}\n")
                if response.status_code != 200:
                    text.insert(END, f"Raw Response: {response.text[:500]}...\n")  # Log first 500 chars
                    response.raise_for_status()
                
                result = response.json()
                issues = result.get('issues', [])
                
                if not issues:
                    break
                
                total_issues += len(issues)
                text.insert(END, f"Fetched {len(issues)} issues in this batch. Total so far: {total_issues}\n")
                
                # Process issues in the batch
                for issue in issues:
                    comments = [c['body'] for c in issue['fields'].get('comment', {}).get('comments', [])]
                    components = [c['name'] for c in issue['fields'].get('components', [])]
                    max_comments = max(max_comments, len(comments))
                    max_components = max(max_components, len(components))
                    
                    row = {
                        'Issue key': issue['key'],
                        'Status': issue['fields']['status']['name']
                    }
                    # Handle components
                    for i in range(max_components):
                        col_name = f'Component{i+1}'
                        row[col_name] = components[i] if i < len(components) else ''
                    
                    # Handle comments
                    for i in range(max_comments):
                        col_name = f'Comment{i+1}'
                        row[col_name] = comments[i] if i < len(comments) else ''
                    
                    data.append(row)
                
                start_at += BATCH_SIZE
                text.see(END)  # Scroll to the latest console output
                root.update()  # Update GUI to keep it responsive
                
                # Add 15-second delay between batch requests
                if issues:  # Only delay if more issues are expected
                    text.insert(END, "Waiting 15 seconds before next batch...\n")
                    text.see(END)
                    time.sleep(15)
            
            except requests.exceptions.RequestException as e:
                text.insert(END, f"API Request Error: {str(e)}\n")
                if 'response' in locals():
                    text.insert(END, f"Status Code: {response.status_code}\n")
                    text.insert(END, f"Raw Response: {response.text[:500]}...\n")  # Log first 500 chars
                messagebox.showerror("Error", f"API Request Failed: {str(e)}")
                return
        
        text.insert(END, f"Total issues fetched: {total_issues}\n")
        
        if data:
            # Create DataFrame with dynamic columns
            df = pd.DataFrame(data)
            filename = os.path.join(current_dir, f"{version}_data.xlsx")
            text.insert(END, f"Exporting to {filename}...\n")
            # Overwrite the file if it exists
            df.to_excel(filename, index=False, engine='openpyxl')
            text.insert(END, "Export complete.\n")
        else:
            text.insert(END, "No data to export.\n")
    
    except Exception as e:
        messagebox.showerror("Error", str(e))
        text.insert(END, f"Error: {str(e)}\n")

# Create GUI
root = Tk()
root.title("Jira Report Generator")
root.geometry("600x400")

# Use ttk for smoother look
style = ttk.Style()
style.theme_use('clam')  # A smoother theme
style.configure('TButton', padding=6)
style.configure('TEntry', padding=5)
style.configure('TLabel', padding=3)

frame = ttk.Frame(root, padding="10")
frame.pack(fill='both', expand=True)

# API Token
ttk.Label(frame, text="Jira API Token:").grid(row=0, column=0, sticky='w', pady=5)
entry_api_token = ttk.Entry(frame, width=50, show='*')
entry_api_token.grid(row=0, column=1, pady=5)

# Load token if it exists
try:
    saved_token = load_token()
    if saved_token:
        entry_api_token.insert(0, '*******')  # Mask token in GUI
except Exception as e:
    text = Text(frame, wrap='word', height=10, borderwidth=2, relief='flat')
    text.insert(END, f"Error loading token: {str(e)}\n")
    text.grid(row=5, column=0, columnspan=2, sticky='nsew')

# Save Token Button
btn_save_token = ttk.Button(frame, text="Save/Update Token", command=save_token)
btn_save_token.grid(row=1, column=0, columnspan=2, pady=5)

# Version
ttk.Label(frame, text="Version (e.g., v12.6.3.9999900):").grid(row=2, column=0, sticky='w', pady=5)
entry_version = ttk.Entry(frame, width=50)
entry_version.grid(row=2, column=1, pady=5)

# Fetch Button
btn_fetch = ttk.Button(frame, text="Fetch and Export Data", command=fetch_data)
btn_fetch.grid(row=3, column=0, columnspan=2, pady=10)

# Console-like text area
ttk.Label(frame, text="Console:").grid(row=4, column=0, sticky='w', pady=5)
text_frame = ttk.Frame(frame)
text_frame.grid(row=5, column=0, columnspan=2, sticky='nsew')

text = Text(text_frame, wrap='word', height=10, borderwidth=2, relief='flat')
text.pack(side='left', fill='both', expand=True)

scrollbar = Scrollbar(text_frame, command=text.yview)
scrollbar.pack(side='right', fill='y')
text.config(yscrollcommand=scrollbar.set)

# Make the text area expand
frame.rowconfigure(5, weight=1)
frame.columnconfigure(1, weight=1)

# Smooth edges for the window
root.resizable(False, False)
root.configure(bg='#f0f0f0')

root.mainloop()