import requests
import pandas as pd
from datetime import datetime
import os
import customtkinter as ctk
from tkinter import messagebox
import threading
from concurrent.futures import ThreadPoolExecutor
from openpyxl import load_workbook
from openpyxl.styles import Border, Side, Alignment, Font
import glob

# Set customtkinter appearance
ctk.set_appearance_mode("System")  # Options: "Light", "Dark", "System"
ctk.set_default_color_theme("blue")  # Options: "blue", "green", "dark-blue"

# Set the working directory to the script's directory
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# GUI Class
class App:
    def __init__(self, root):
        self.root = root
        self.root.title("DefectDojo and Contrast Data Mapper")
        self.root.geometry("600x400")

        # Main frame
        self.main_frame = ctk.CTkFrame(self.root)
        self.main_frame.pack(pady=10, padx=10, fill="both", expand=True)

        # Start button
        self.start_button = ctk.CTkButton(
            self.main_frame, text="Start", command=self.start_script, width=200
        )
        self.start_button.pack(pady=10)

        # Loading label
        self.loading_label = ctk.CTkLabel(self.main_frame, text="")
        self.loading_label.pack(pady=5)

        # Progress bar
        self.progress = ctk.CTkProgressBar(self.main_frame, width=400)
        self.progress.set(0)
        self.progress.pack(pady=5)

        # Console log area
        self.log_text = ctk.CTkTextbox(self.main_frame, height=200, width=580, state="disabled")
        self.log_text.pack(pady=10, fill="both", expand=True)

    def log(self, message):
        self.log_text.configure(state="normal")
        self.log_text.insert("end", f"{datetime.now().strftime('%H:%M:%S')}: {message}\n")
        self.log_text.configure(state="disabled")
        self.log_text.see("end")

    def start_script(self):
        self.start_button.configure(state="disabled")
        self.loading_label.configure(text="Loading...")
        self.animate_loading()
        threading.Thread(target=self.run_script_thread, daemon=True).start()

    def animate_loading(self):
        def update_dots():
            if self.loading_label.cget("text").startswith("Loading"):
                dots = self.loading_label.cget("text")[7:]
                if dots == "...":
                    self.loading_label.configure(text="Loading")
                else:
                    self.loading_label.configure(text="Loading" + dots + ".")
                self.root.after(1000, update_dots)
        self.root.after(1000, update_dots)

    def clear_xlsx_files(self):
        self.log("Clearing existing .xlsx files...")
        for file in glob.glob(os.path.join(script_dir, "*.xlsx")):
            try:
                os.remove(file)
                self.log(f"Deleted {os.path.basename(file)}")
            except Exception as e:
                self.log(f"Error deleting {os.path.basename(file)}: {e}")
        self.progress.set(0.05)

    def run_script_thread(self):
        # Step 1: Clear existing .xlsx files
        self.clear_xlsx_files()

        # Step 2: Fetch app_id:id mappings from DefectDojo text file
        self.log("Fetching DefectDojo app_id:id mappings...")
        self.fetch_defectdojo_mappings()
        self.progress.set(0.3)

        # Step 3: Fetch Contrast applications
        self.log("Fetching Contrast applications...")
        applications = self.fetch_contrast_applications()
        self.progress.set(0.5)

        # Step 4: Fetch traces
        self.log("Fetching Contrast traces...")
        self.fetch_contrast_traces(applications)
        self.progress.set(0.65)

        # Step 5: Remove duplicates from Traces.xlsx
        self.log("Removing duplicates from Traces.xlsx...")
        self.remove_duplicates_from_traces()
        self.progress.set(0.8)

        # Step 6: Match and generate Final.xlsx
        self.log("Matching traces with mappings, generating Final.xlsx...")
        self.generate_final_xlsx()
        self.progress.set(1.0)

        # Finalize
        self.loading_label.configure(text="")
        self.start_button.configure(state="normal")
        self.log("Script execution completed.")
        self.root.after(
            0, lambda: messagebox.showinfo("Success", "Final.xlsx generated successfully")
        )

    def fetch_defectdojo_mappings(self):
        mapping_url = "https://demo.defectdojo.org/access_file/5039/72668/Engagement"
        headers = {"Authorization": "Token jdndjdjjd"}  # Replace with actual token
        mappings = []

        try:
            response = requests.get(mapping_url, headers=headers, timeout=10)
            if response.status_code == 200:
                # Parse text file content (format: app_id:id per line)
                lines = response.text.strip().split("\n")
                for line in lines:
                    if ":" in line:
                        app_id, defectdojo_id = line.split(":", 1)
                        mappings.append({"app_id": app_id.strip(), "id": defectdojo_id.strip()})
                df = pd.DataFrame(mappings)
                df.to_excel(os.path.join(script_dir, "products.xlsx"), index=False)
                self.log(f"Mappings saved to products.xlsx ({len(mappings)} mappings)")
            else:
                self.log(f"Error fetching DefectDojo mappings: {response.status_code} - {response.text}")
        except Exception as e:
            self.log(f"Exception fetching DefectDojo mappings: {e}")

    def fetch_contrast_applications(self):
        contrast_token = "dhdjdjdjdjrjrjrjdj=="  # Replace with actual token
        org_uuid = "gshdhdhd"  # Replace with actual Org UUID
        api_key = "hhjkkjdddjdkdk"  # Replace with actual API key

        headers = {
            "Authorization": contrast_token,
            "API-Key": api_key,
            "Accept": "application/json",
        }

        base_url = "https://contrast.crm.com/Contrast/api/ng/"
        url = f"{base_url}{org_uuid}/applications/filter"
        applications = []

        with requests.Session() as session:
            session.headers.update(headers)
            try:
                response = session.get(url, timeout=10)
                if response.status_code == 200:
                    data = response.json()
                    for app in data.get("applications", []):
                        applications.append(
                            {"name": app.get("name", ""), "app_id": app.get("app_id", "")}
                        )
                    df = pd.DataFrame(applications)
                    df.to_excel(os.path.join(script_dir, "Applications.xlsx"), index=False)
                    self.log(f"Applications saved to Applications.xlsx ({len(applications)} applications)")
                else:
                    self.log(f"Error fetching applications: {response.status_code} - {response.text}")
            except Exception as e:
                self.log(f"Exception fetching applications: {e}")

        return applications

    def fetch_contrast_traces(self, applications):
        contrast_token = "dhdjdjdjdjrjrjrjdj=="  # Replace with actual token
        org_uuid = "gshdhdhd"  # Replace with actual Org UUID
        api_key = "hhjkkjdddjdkdk"  # Replace with actual API key

        headers = {
            "Authorization": contrast_token,
            "API-Key": api_key,
            "Accept": "application/json",
        }

        base_url = "https://contrast.crm.com/Contrast/api/ng/"
        traces = []

        def fetch_traces_for_app(app):
            app_id = app["app_id"]
            url = f"{base_url}{org_uuid}/traces/{app_id}/filter?limit=100&status=Reported Patron
            app_traces = []
            try:
                response = session.get(url, timeout=10)
                if response.status_code == 200:
                    data = response.json()
                    for trace in data.get("traces", []):
                        app_traces.append(
                            {
                                "name": app["name"],
                                "app_id": app_id,
                                "Trace ID": trace.get("uuid", ""),
                                "Severity": trace.get("severity", ""),
                                "Status": trace.get("status", ""),
                                "Rule": trace.get("rule_title", ""),
                                "Trace Title": trace.get("title", ""),
                            }
                        )
                else:
                    self.log(f"Error for App ID {app_id}: {response.status_code} - {response.text}")
            except Exception as e:
                self.log(f"Exception for App ID {app_id}: {e}")
            return app_traces

        with requests.Session() as session:
            session.headers.update(headers)
            with ThreadPoolExecutor(max_workers=10) as executor:
                results = list(executor.map(fetch_traces_for_app, applications))

        for result in results:
            traces.extend(result)

        df = pd.DataFrame(traces)
        df.to_excel(os.path.join(script_dir, "Traces.xlsx"), index=False)
        self.log(f"Traces saved to Traces.xlsx ({len(traces)} traces)")

    def remove_duplicates_from_traces(self):
        try:
            traces_df = pd.read_excel(os.path.join(script_dir, "Traces.xlsx"))
            initial_count = len(traces_df)
            traces_df = traces_df.drop_duplicates(subset=["Trace ID"], keep="first")
            final_count = len(traces_df)
            traces_df.to_excel(os.path.join(script_dir, "Traces.xlsx"), index=False)
            self.log(f"Removed {initial_count - final_count} duplicate traces. {final_count} traces remain in Traces.xlsx")
        except FileNotFoundError:
            self.log("Error: Traces.xlsx not found.")
        except Exception as e:
            self.log(f"Error removing duplicates: {e}")

    def generate_final_xlsx(self):
        try:
            products_df = pd.read_excel(os.path.join(script_dir, "products.xlsx"))
            traces_df = pd.read_excel(os.path.join(script_dir, "Traces.xlsx"))
        except FileNotFoundError as e:
            self.log(f"Error: {e}")
            return

        final_data = []
        # Create a dictionary for quick app_id to id lookup
        mapping_dict = dict(zip(products_df["app_id"], products_df["id"]))

        for _, trace_row in traces_df.iterrows():
            trace_app_id = trace_row["app_id"]
            defectdojo_id = mapping_dict.get(trace_app_id, 33)  # Default to 33 if no match

            final_data.append(
                {
                    "Trace ID": trace_row["Trace ID"],
                    "Severity": trace_row["Severity"],
                    "Status": trace_row["Status"],
                    "Rule": trace_row["Rule"],
                    "Trace Title": trace_row["Trace Title"],
                    "name": trace_row["name"],
                    "app_id": trace_row["app_id"],
                    "id": defectdojo_id,
                }
            )

        if not final_data:
            self.log("No traces found to process.")
            return

        columns = [
            "Trace ID",
            "Severity",
            "Status",
            "Rule",
            "Trace Title",
            "name",
            "app_id",
            "id",
        ]
        df = pd.DataFrame(final_data, columns=columns)
        excel_file = os.path.join(script_dir, "Final.xlsx")
        df.to_excel(excel_file, index=False)
        self.log(f"Final data saved to Final.xlsx ({len(final_data)} traces, {sum(1 for d in final_data if d['id'] != 33)} matched)")

        # Apply formatting
        wb = load_workbook(excel_file)
        ws = wb.active

        medium_border = Border(
            left=Side(style="medium"),
            right=Side(style="medium"),
            top=Side(style="medium"),
            bottom=Side(style="medium"),
        )
        thin_border = Border(
            left=Side(style="thin"),
            right=Side(style="thin"),
            top=Side(style="thin"),
            bottom=Side(style="thin"),
        )
        center_align = Alignment(horizontal="center", vertical="center")
        left_align = Alignment(horizontal="left", vertical="center")
        bold_font = Font(bold=True)

        for col_idx in range(1, ws.max_column + 1):
            cell = ws.cell(row=1, column=col_idx)
            cell.font = bold_font
            cell.alignment = center_align if col_idx > 1 else left_align
            cell.border = thin_border

        for row_idx in range(2, ws.max_row + 1):
            for col_idx in range(1, ws.max_column + 1):
                cell = ws.cell(row=row_idx, column=col_idx)
                cell.alignment = center_align if col_idx > 1 else left_align
                cell.border = thin_border

        wb.save(excel_file)
        self.log("Formatting applied to Final.xlsx")

if __name__ == "__main__":
    root = ctk.CTk()
    app = App(root)
    root.mainloop()