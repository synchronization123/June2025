<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DefectDojo Patch Summary</title>
    <!-- Include SheetJS for Excel export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .input-section {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .input-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        label {
            display: inline-block;
            width: 180px;
            font-weight: bold;
        }
        input[type="date"] {
            padding: 8px;
            width: 200px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            margin-right: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #218838;
        }
        #exportButton {
            background-color: #007bff;
        }
        #exportButton:hover {
            background-color: #0056b3;
        }
        #exportButton:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        #totalCount {
            margin-top: 10px;
            font-weight: bold;
        }
        #statusCounts {
            margin-top: 10px;
            font-weight: bold;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }
        th {
            background-color: #007bff;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .error, .info {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .info {
            background-color: #d4edda;
            color: #155724;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <h2>DefectDojo Patch Summary</h2>
            <div class="input-group">
                <label for="date1">Start Date:</label>
                <input type="date" id="date1">
                <span id="statusCounts" style="margin-left: 20px;">
                    Approved Count: 0 | Approved with Exception Count: 0 | Rejected Count: 0
                </span>
            </div>
            <div class="input-group">
                <label for="date2">End Date:</label>
                <input type="date" id="date2">
            </div>
            <button onclick="fetchAndDisplay()">Fetch Data</button>
            <button id="exportButton" onclick="exportToExcel()" disabled>Export Data</button>
            <div id="totalCount">Total: 0</div>
        </div>
        <div id="message"></div>
        <table id="dataTable" style="display: none;">
            <thead>
                <tr>
                    <th>Patch</th>
                    <th>Creation Date</th>
                    <th>Status</th>
                    <th>Review Status</th>
                    <th>Completion Date</th>
                    <th>Timeline (Days)</th>
                    <th>IR</th>
                    <th>No. of Jiras</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>
    <div id="loadingModal" class="modal">
        <div class="modal-content">
            <h3>Loading...</h3>
            <div class="loader"></div>
        </div>
    </div>

    <script>
        const apiUrl = "https://demo.defectdojo.org/api/v2/";
        let tableData = []; // Store data for export

        function showMessage(text, type) {
            const messageDiv = document.getElementById("message");
            messageDiv.textContent = text;
            messageDiv.className = type;
            messageDiv.style.display = "block";
            setTimeout(() => { messageDiv.style.display = "none"; }, 5000);
        }

        function showLoadingModal(show) {
            document.getElementById("loadingModal").style.display = show ? "flex" : "none";
        }

        function validateDate(dateStr) {
            if (!dateStr) return null;
            const regex = /^\d{4}-\d{2}-\d{2}$/;
            if (!regex.test(dateStr)) return null;
            const date = new Date(dateStr);
            return isNaN(date) ? null : date;
        }

        function formatDateToYMD(date) {
            if (!date) return "";
            return date.toISOString().split("T")[0]; // Ensures YYYY-MM-DD
        }

        async function fetchEngagements(startDate, endDate) {
            const url = `${apiUrl}engagements/`;
            const params = new URLSearchParams({
                tags: "patches",
                created__gte: startDate.toISOString(),
                created__lte: endDate.toISOString(),
                offset: 0,
                limit: 1000,
                o: "-created" // Sort by created in descending order
            });
            try {
                const response = await fetch(`${url}?${params}`);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                return data.results || [];
            } catch (error) {
                showMessage(`Failed to fetch engagements: ${error.message}`, "error");
                return [];
            }
        }

        async function fetchJiraCount(engagementId) {
            const url = `${apiUrl}tests/`;
            const params = new URLSearchParams({
                engagement: engagementId,
                tags: "patch_jira"
            });
            try {
                const response = await fetch(`${url}?${params}`);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                return data.count || 0;
            } catch (error) {
                console.warn(`Failed to fetch JIRA count for engagement ${engagementId}: ${error.message}`);
                return 0;
            }
        }

        function processEngagements(engagements, startDate, endDate) {
            const startDateStr = formatDateToYMD(startDate);
            const endDateStr = formatDateToYMD(endDate);
            const data = [];
            for (const engagement of engagements) {
                // Exclude engagements where status is not "Completed"
                if (engagement.status !== "Completed") continue;

                const created = engagement.created ? new Date(engagement.created) : null;
                const createdStr = created ? formatDateToYMD(created) : "";
                // Filter strictly by created date range (inclusive)
                if (createdStr < startDateStr || createdStr > endDateStr) continue;

                const updated = engagement.updated ? new Date(engagement.updated) : null;
                let commitHash = engagement.commit_hash || "Not Started";
                let reviewStatus = commitHash === "Not Started" || commitHash === "" ? "Approved" : commitHash;
                if (!["Approved with Exception", "Rejected", "Approved"].includes(reviewStatus)) {
                    reviewStatus = "Approved";
                }
                const timelineDays = created && updated ? Math.round((updated - created) / (1000 * 60 * 60 * 24)) : 0;

                data.push({
                    Patch: engagement.name || "",
                    "Creation Date": createdStr,
                    Status: "Completed", // Hardcoded as per original requirement
                    "Review Status": reviewStatus,
                    "Completion Date": formatDateToYMD(updated),
                    "Timeline (Days)": timelineDays,
                    IR: engagement.version || "",
                    "No. of Jiras": 0, // Placeholder
                    engagementId: engagement.id // Store ID for JIRA count
                });
            }
            return data;
        }

        async function populateJiraCounts(data) {
            for (const row of data) {
                if (row.engagementId) {
                    row["No. of Jiras"] = await fetchJiraCount(row.engagementId);
                }
            }
        }

        function displayInTable(data) {
            const tableBody = document.getElementById("tableBody");
            tableBody.innerHTML = "";
            for (const row of data) {
                const tr = document.createElement("tr");
                tr.innerHTML = `
                    <td>${row.Patch}</td>
                    <td>${row["Creation Date"]}</td>
                    <td>${row.Status}</td>
                    <td>${row["Review Status"]}</td>
                    <td>${row["Completion Date"]}</td>
                    <td>${row["Timeline (Days)"]}</td>
                    <td>${row.IR}</td>
                    <td>${row["No. of Jiras"]}</td>
                `;
                tableBody.appendChild(tr);
            }
            document.getElementById("dataTable").style.display = data.length ? "table" : "none";
            document.getElementById("totalCount").textContent = `Total: ${data.length}`;

            // Update status counts
            const approvedCount = data.filter(row => row["Review Status"] === "Approved").length;
            const approvedWithExceptionCount = data.filter(row => row["Review Status"] === "Approved with Exception").length;
            const rejectedCount = data.filter(row => row["Review Status"] === "Rejected").length;
            document.getElementById("statusCounts").textContent = 
                `Approved Count: ${approvedCount} | Approved with Exception Count: ${approvedWithExceptionCount} | Rejected Count: ${rejectedCount}`;
        }

        function exportToExcel() {
            if (!tableData.length) {
                showMessage("No data to export.", "error");
                return;
            }
            const date1 = document.getElementById("date1").value;
            const date2 = document.getElementById("date2").value;
            const exportData = tableData.map(({ engagementId, ...rest }) => rest);
            const ws = XLSX.utils.json_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Patches");
            const filename = `patches_completed_${date1}-${date2}.xlsx`;
            XLSX.writeFile(wb, filename);
        }

        async function fetchAndDisplay() {
            const date1Str = document.getElementById("date1").value;
            const date2Str = document.getElementById("date2").value;

            const date1 = validateDate(date1Str);
            const date2 = validateDate(date2Str);

            if (!date1 || !date2) {
                showMessage("Invalid date format. Use YYYY-MM-DD.", "error");
                return;
            }

            if (date1 > date2) {
                showMessage("Start date must be before or equal to end date.", "error");
                return;
            }

            showLoadingModal(true);
            document.getElementById("exportButton").disabled = true;
            document.getElementById("totalCount").textContent = "Total: 0";
            document.getElementById("statusCounts").textContent = "Approved Count: 0 | Approved with Exception Count: 0 | Rejected Count: 0";

            // Adjust dates for midnight to midnight (inclusive)
            date1.setHours(0, 0, 0, 0);
            date2.setHours(23, 59, 59, 999);

            const engagements = await fetchEngagements(date1, date2);
            if (!engagements.length) {
                showLoadingModal(false);
                showMessage("No engagements found for the selected date range with tag 'patches' and status 'Completed'.", "info");
                return;
            }

            tableData = processEngagements(engagements, date1, date2);
            await populateJiraCounts(tableData);
            displayInTable(tableData);
            showLoadingModal(false);
            document.getElementById("exportButton").disabled = !tableData.length;
        }
    </script>
</body>
</html>