import requests
import pandas as pd
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
import os
import datetime
import tkinter as tk
from tkinter import ttk, messagebox
import threading
import time
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
import logging

# Set working directory to the script's directory
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# Create data folder if not exists
data_folder = os.path.join(script_dir, 'data')
try:
    os.makedirs(data_folder, exist_ok=True)
except Exception as e:
    logging.error(f"Failed to create data folder: {e}")

# Set up logging to file and console
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(script_dir, 'trace_download.log')),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class UtilityApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Contrast Traces Utility")
        self.root.geometry("600x400")

        # Button frame
        self.button_frame = ttk.Frame(self.root)
        self.button_frame.pack(pady=10)
        self.fetch_button = ttk.Button(self.button_frame, text="Fetch", command=self.start_fetch)
        self.fetch_button.pack()

        # Log frame
        self.log_frame = ttk.Frame(self.root)
        self.log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.log_text = tk.Text(self.log_frame, height=20, width=70, state='disabled')
        self.log_text.pack(fill=tk.BOTH, expand=True)
        scrollbar = ttk.Scrollbar(self.log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text['yscrollcommand'] = scrollbar.set

    def log(self, message):
        logger.info(message)
        self.log_text.configure(state='normal')
        self.log_text.insert(tk.END, f"{datetime.datetime.now().strftime('%H:%M:%S')}: {message}\n")
        self.log_text.configure(state='disabled')
        self.log_text.see(tk.END)
        self.root.update_idletasks()

    def start_fetch(self):
        self.fetch_button.config(state='disabled')
        threading.Thread(target=self.run_logic, daemon=True).start()

    def run_logic(self):
        self.log("Starting utility...")

        # API credentials (replace with actual values)
        contrast_token = '<<TOKEN>>'
        org_uuid = '<<UUID>>'
        api_key = '<<APIKEY>>'

        # Validate credentials
        if '<<' in contrast_token or '<<' in org_uuid or '<<' in api_key:
            self.log("Error: Please replace <<TOKEN>>, <<UUID>>, and <<APIKEY>> with actual credentials")
            self.fetch_button.config(state='normal')
            self.root.after(0, lambda: messagebox.showerror("Error", "Invalid API credentials"))
            return

        # Base URL
        base_url = 'https://contrast.abc.com/Contrast/api/ng/'

        # Headers
        headers = {
            'Authorization': contrast_token,
            'Api-key': api_key,
            'Accept': 'application/json'
        }

        # Define 14 application IDs and their aliases
        app_aliases = {
            'hhdjdjdjd': 'CRM',
            'kkdjdj': 'DRM',
            'app_id3': 'App3',
            'app_id4': 'App4',
            'app_id5': 'App5',
            'app_id6': 'App6',
            'app_id7': 'App7',
            'app_id8': 'App8',
            'app_id9': 'App9',
            'app_id10': 'App10',
            'app_id11': 'App11',
            'app_id12': 'App12',
            'app_id13': 'App13',
            'app_id14': 'App14'
        }
        app_ids = list(app_aliases.keys())

        # Current date
        today = datetime.datetime.now()
        today_str = today.strftime('%Y-%m-%d')
        date_formatted = today.strftime('%d-%b-%Y')
        daily_file = os.path.join(data_folder, f'Contrast_Traces_{today_str}.xlsx')

        # Step 1: Download traces and save to daily Excel
        self.log(f"Downloading traces for {today_str}...")
        daily_data = []
        traces_counts = {alias: 0 for alias in app_aliases.values()}

        with requests.Session() as session:
            session.headers.update(headers)
            for app_id in app_ids:
                alias = app_aliases[app_id]
                self.log(f"Fetching traces for {alias} ({app_id}) with status 'Reported'...")
                offset = 0
                limit = 500  # Fetch 500 traces per request
                delay = 0.5  # Delay between requests in seconds
                while True:
                    url = f"{base_url}{org_uuid}/orgtraces/ids?status=Reported&applicationID={app_id}&limit={limit}&offset={offset}&sort=-last_time_seen"
                    try:
                        @retry(
                            stop=stop_after_attempt(3),
                            wait=wait_exponential(multiplier=1, min=4, max=10),
                            retry=retry_if_exception_type((requests.exceptions.RequestException,))
                        )
                        def make_request():
                            return session.get(url, timeout=30)

                        response = make_request()
                        if response.status_code == 200:
                            data = response.json()
                            self.log(f"Raw API response for {alias} at offset {offset}: {data}")
                            # Handle different response formats
                            traces_fetched = []
                            if isinstance(data, list):
                                traces_fetched = data  # Direct list of trace IDs
                            elif isinstance(data, dict):
                                traces_fetched = data.get('traces', []) or data.get('ids', [])  # Check common keys
                            else:
                                self.log(f"Unexpected response format for {alias}: {type(data)}")
                                break

                            self.log(f"Fetched {len(traces_fetched)} traces for {alias} at offset {offset}")
                            for trace in traces_fetched:
                                trace_id = trace if isinstance(trace, str) else trace.get('uuid', trace.get('id', ''))
                                if trace_id:
                                    daily_data.append({
                                        'Date': date_formatted,
                                        'Application': alias,
                                        'Trace': trace_id
                                    })
                                    traces_counts[alias] += 1
                            if len(traces_fetched) < limit:
                                break  # No more traces to fetch
                            offset += limit
                            time.sleep(delay)
                        elif response.status_code == 429:
                            self.log(f"Rate limit exceeded for {alias}. Waiting longer...")
                            time.sleep(5)  # Wait longer for rate limit
                            continue
                        else:
                            self.log(f"Error fetching traces for {alias}: {response.status_code} - {response.text}")
                            break
                    except Exception as e:
                        self.log(f"Exception fetching traces for {alias} at offset {offset}: {e}")
                        break

        # Save daily traces to Excel
        self.log(f"Saving daily traces to {daily_file}...")
        try:
            df = pd.DataFrame(daily_data)
            df.to_excel(daily_file, index=False)
            wb = openpyxl.load_workbook(daily_file)
            ws = wb.active
            ws.title = 'Traces'

            # Format header
            thin_border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))
            for col in range(1, 4):
                cell = ws.cell(row=1, column=col)
                cell.font = Font(bold=True)
                cell.alignment = Alignment(horizontal='center')
                cell.border = thin_border

            # Format data rows
            for row in range(2, ws.max_row + 1):
                for col in range(1, 4):
                    cell = ws.cell(row=row, column=col)
                    cell.alignment = Alignment(horizontal='center' if col > 1 else 'left')
                    cell.border = thin_border

            wb.save(daily_file)
            self.log(f"Daily traces saved to {daily_file} (Total: {len(daily_data)})")
        except Exception as e:
            self.log(f"Error saving daily traces to {daily_file}: {e}")
            self.fetch_button.config(state='normal')
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to save daily traces: {e}"))
            return

        # Step 2: Update Final.xlsx with counts
        self.log("Updating Final.xlsx...")
        final_file = os.path.join(script_dir, 'Final.xlsx')
        try:
            final_wb = openpyxl.load_workbook(final_file)
        except FileNotFoundError:
            self.log("Final.xlsx not found, creating new...")
            final_wb = openpyxl.Workbook()
            final_ws = final_wb.active
            final_ws.title = 'Summary'
            final_ws['A1'] = 'Applications'
            # Add app aliases
            for row, alias in enumerate(app_aliases.values(), start=2):
                final_ws.cell(row=row, column=1).value = alias
            # Add total row
            total_row = len(app_aliases) + 2
            final_ws.cell(row=total_row, column=1).value = 'Total'

        final_ws = final_wb.active

        # Find or add date column
        date_column = None
        last_column = final_ws.max_column
        for col in range(2, last_column + 1):
            if final_ws.cell(row=1, column=col).value == date_formatted:
                date_column = col
                self.log(f"Overwriting existing column for {date_formatted} at column {col}")
                break
        if date_column is None:
            date_column = last_column + 1
            final_ws.cell(row=1, column=date_column).value = date_formatted
            self.log(f"Adding new column for {date_formatted} at column {date_column}")

        # Clear existing data in the column (except header)
        for row in range(2, final_ws.max_row + 1):
            final_ws.cell(row=row, column=date_column).value = None
            final_ws.cell(row=row, column=date_column).fill = PatternFill()  # Clear fill

        # Update counts
        green_fill = PatternFill(start_color='90EE90', end_color='90EE90', fill_type='solid')
        for row in range(2, final_ws.max_row):
            app_cell = final_ws.cell(row=row, column=1)
            if app_cell.value in traces_counts:
                count = traces_counts[app_cell.value]
                count_cell = final_ws.cell(row=row, column=date_column)
                if count > 0:
                    count_cell.value = count
                else:
                    count_cell.fill = green_fill

        # Update total row
        total_row = final_ws.max_row
        if final_ws.cell(row=total_row, column=1).value == 'Total':
            sum_formula = f"=SUM({openpyxl.utils.get_column_letter(date_column)}2:{openpyxl.utils.get_column_letter(date_column)}{total_row-1})"
            total_cell = final_ws.cell(row=total_row, column=date_column)
            total_cell.value = sum_formula
        else:
            total_row = final_ws.max_row + 1
            final_ws.cell(row=total_row, column=1).value = 'Total'
            sum_formula = f"=SUM({openpyxl.utils.get_column_letter(date_column)}2:{openpyxl.utils.get_column_letter(date_column)}{total_row-1})"
            total_cell = final_ws.cell(row=total_row, column=date_column)
            total_cell.value = sum_formula

        # Apply formatting
        thin_border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))
        # Header row
        for col in range(1, final_ws.max_column + 1):
            cell = final_ws.cell(row=1, column=col)
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border

        # Column A left aligned
        for row in range(2, final_ws.max_row + 1):
            cell = final_ws.cell(row=row, column=1)
            cell.alignment = Alignment(horizontal='left')
            cell.border = thin_border

        # Other columns center aligned
        for row in range(2, final_ws.max_row + 1):
            for col in range(2, final_ws.max_column + 1):
                cell = final_ws.cell(row=row, column=col)
                cell.alignment = Alignment(horizontal='center')
                cell.border = thin_border

        # Total row bold
        for col in range(1, final_ws.max_column + 1):
            final_ws.cell(row=total_row, column=col).font = Font(bold=True)

        # Save Final.xlsx
        try:
            final_wb.save(final_file)
            self.log(f"Final.xlsx updated with counts for {date_formatted}")
        except Exception as e:
            self.log(f"Error saving Final.xlsx: {e}")
            self.fetch_button.config(state='normal')
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to save Final.xlsx: {e}"))
            return

        self.log("Utility completed.")
        self.fetch_button.config(state='normal')
        self.root.after(0, lambda: messagebox.showinfo("Success", f"Traces downloaded and Final.xlsx updated for {date_formatted}"))

if __name__ == "__main__":
    root = tk.Tk()
    app = UtilityApp(root)
    root.mainloop()