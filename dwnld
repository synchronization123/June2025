import requests
import pandas as pd
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
import os
import datetime
import tkinter as tk
from tkinter import ttk
import threading
import time
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

# Set working directory to the script's directory
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

# Create data folder if not exists
data_folder = os.path.join(script_dir, 'data')
os.makedirs(data_folder, exist_ok=True)

class UtilityApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Contrast Traces Utility")
        self.root.geometry("600x400")

        # Log frame
        self.log_frame = ttk.Frame(self.root)
        self.log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.log_text = tk.Text(self.log_frame, height=20, width=70, state='disabled')
        self.log_text.pack(fill=tk.BOTH, expand=True)
        scrollbar = ttk.Scrollbar(self.log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text['yscrollcommand'] = scrollbar.set

        # Start the main logic in a separate thread
        threading.Thread(target=self.run_logic, daemon=True).start()

    def log(self, message):
        self.log_text.configure(state='normal')
        self.log_text.insert(tk.END, f"{datetime.datetime.now().strftime('%H:%M:%S')}: {message}\n")
        self.log_text.configure(state='disabled')
        self.log_text.see(tk.END)
        self.root.update_idletasks()

    def run_logic(self):
        self.log("Starting utility...")

        # API credentials (replace with actual values)
        contrast_token = '<<TOKEN>>'
        org_uuid = '<<UUID>>'
        api_key = '<<APIKEY>>'

        # Base URL
        base_url = 'https://contrast.abc.com/Contrast/api/ng/'

        # Headers
        headers = {
            'Authorization': contrast_token,
            'Api-key': api_key,
            'Accept': 'application/json'
        }

        # Define 14 application IDs and their aliases
        app_aliases = {
            'hhdjdjdjd': 'CRM',
            'kkdjdj': 'DRM',
            'app_id3': 'App3',
            'app_id4': 'App4',
            'app_id5': 'App5',
            'app_id6': 'App6',
            'app_id7': 'App7',
            'app_id8': 'App8',
            'app_id9': 'App9',
            'app_id10': 'App10',
            'app_id11': 'App11',
            'app_id12': 'App12',
            'app_id13': 'App13',
            'app_id14': 'App14'
        }
        app_ids = list(app_aliases.keys())

        # Current date
        today = datetime.datetime.now()
        today_str = today.strftime('%Y-%m-%d')
        date_formatted = today.strftime('%d-%b-%Y')
        daily_file = os.path.join(data_folder, f'Contrast_Traces_{today_str}.xlsx')

        # Step 1: Download traces and save to daily Excel
        self.log(f"Downloading traces for {today_str}...")
        daily_data = []
        traces_counts = {alias: 0 for alias in app_aliases.values()}

        with requests.Session() as session:
            session.headers.update(headers)
            for app_id in app_ids:
                alias = app_aliases[app_id]
                self.log(f"Fetching traces for {alias} ({app_id}) with status 'Reported'...")
                offset = 0
                limit = 500  # Fetch 500 traces per request
                delay = 0.5  # Delay between requests in seconds
                while True:
                    url = f"{base_url}{org_uuid}/orgtraces/id?appId={app_id}&status=Reported&limit={limit}&offset={offset}&sort=-last_time_seen"
                    try:
                        @retry(
                            stop=stop_after_attempt(3),
                            wait=wait_exponential(multiplier=1, min=4, max=10),
                            retry=retry_if_exception_type((requests.exceptions.RequestException,))
                        )
                        def make_request():
                            return session.get(url, timeout=30)

                        response = make_request()
                        if response.status_code == 200:
                            data = response.json()
                            traces_fetched = data.get('traces', [])
                            self.log(f"Fetched {len(traces_fetched)} traces for {alias} at offset {offset}")
                            for trace in traces_fetched:
                                daily_data.append({
                                    'Date': date_formatted,
                                    'Application': alias,
                                    'Trace': trace.get('uuid', '')
                                })
                                traces_counts[alias] += 1
                            if len(traces_fetched) < limit:
                                break  # No more traces to fetch
                            offset += limit
                            time.sleep(delay)
                        else:
                            self.log(f"Error fetching traces for {alias}: {response.status_code} - {response.text}")
                            break
                    except Exception as e:
                        self.log(f"Exception fetching traces for {alias}: {e}")
                        break

        # Save daily traces to Excel
        if daily_data:
            df = pd.DataFrame(daily_data)
            df.to_excel(daily_file, index=False)
            wb = openpyxl.load_workbook(daily_file)
            ws = wb.active
            ws.title = 'Traces'

            # Format header
            for col in range(1, 4):
                cell = ws.cell(row=1, column=col)
                cell.font = Font(bold=True)
                cell.alignment = Alignment(horizontal='center')
                cell.border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))

            # Format data rows
            for row in range(2, ws.max_row + 1):
                for col in range(1, 4):
                    cell = ws.cell(row=row, column=col)
                    cell.alignment = Alignment(horizontal='center' if col > 1 else 'left')
                    cell.border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))

            wb.save(daily_file)
            self.log(f"Daily traces saved to {daily_file}")
        else:
            self.log("No traces found for today.")

        # Step 2: Update Final.xlsx with counts
        self.log("Updating Final.xlsx...")
        final_file = os.path.join(script_dir, 'Final.xlsx')
        try:
            final_wb = openpyxl.load_workbook(final_file)
        except FileNotFoundError:
            self.log("Final.xlsx not found, creating new...")
            final_wb = openpyxl.Workbook()
            final_ws = final_wb.active
            final_ws.title = 'Summary'
            final_ws['A1'] = 'Applications'
            # Add app aliases
            for row, alias in enumerate(app_aliases.values(), start=2):
                final_ws.cell(row=row, column=1).value = alias
            # Add total row
            total_row = len(app_aliases) + 2
            final_ws.cell(row=total_row, column=1).value = 'Total'

        final_ws = final_wb.active

        # Find or add date column
        date_column = None
        last_column = final_ws.max_column
        for col in range(2, last_column + 1):
            if final_ws.cell(row=1, column=col).value == date_formatted:
                date_column = col
                self.log(f"Overwriting existing column for {date_formatted} at column {col}")
                break
        if date_column is None:
            date_column = last_column + 1
            final_ws.cell(row=1, column=date_column).value = date_formatted
            self.log(f"Adding new column for {date_formatted} at column {date_column}")

        # Clear existing data in the column (except header)
        for row in range(2, final_ws.max_row + 1):
            final_ws.cell(row=row, column=date_column).value = None
            final_ws.cell(row=row, column=date_column).fill = PatternFill()  # Clear fill

        # Update counts
        green_fill = PatternFill(start_color='90EE90', end_color='90EE90', fill_type='solid')
        for row in range(2, final_ws.max_row):
            app_cell = final_ws.cell(row=row, column=1)
            if app_cell.value in traces_counts:
                count = traces_counts[app_cell.value]
                count_cell = final_ws.cell(row=row, column=date_column)
                if count > 0:
                    count_cell.value = count
                else:
                    count_cell.fill = green_fill

        # Update total row
        total_row = final_ws.max_row
        if final_ws.cell(row=total_row, column=1).value == 'Total':
            sum_formula = f"=SUM({openpyxl.utils.get_column_letter(date_column)}2:{openpyxl.utils.get_column_letter(date_column)}{total_row-1})"
            total_cell = final_ws.cell(row=total_row, column=date_column)
            total_cell.value = sum_formula
        else:
            total_row = final_ws.max_row + 1
            final_ws.cell(row=total_row, column=1).value = 'Total'
            sum_formula = f"=SUM({openpyxl.utils.get_column_letter(date_column)}2:{openpyxl.utils.get_column_letter(date_column)}{total_row-1})"
            total_cell = final_ws.cell(row=total_row, column=date_column)
            total_cell.value = sum_formula

        # Apply formatting
        thin_border = Border(left=Side('thin'), right=Side('thin'), top=Side('thin'), bottom=Side('thin'))
        # Header row
        for col in range(1, final_ws.max_column + 1):
            cell = final_ws.cell(row=1, column=col)
            cell.font = Font(bold=True)
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border

        # Column A left aligned
        for row in range(2, final_ws.max_row + 1):
            cell = final_ws.cell(row=row, column=1)
            cell.alignment = Alignment(horizontal='left')
            cell.border = thin_border

        # Other columns center aligned
        for row in range(2, final_ws.max_row + 1):
            for col in range(2, final_ws.max_column + 1):
                cell = final_ws.cell(row=row, column=col)
                cell.alignment = Alignment(horizontal='center')
                cell.border = thin_border

        # Total row bold
        for col in range(1, final_ws.max_column + 1):
            final_ws.cell(row=total_row, column=col).font = Font(bold=True)

        # Save Final.xlsx
        final_wb.save(final_file)
        self.log(f"Final.xlsx updated with counts for {date_formatted}")

        self.log("Utility completed.")

if __name__ == "__main__":
    root = tk.Tk()
    app = UtilityApp(root)
    root.mainloop()