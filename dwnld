import tkinter as tk
from tkinter import ttk, messagebox, Toplevel
import requests
import threading
import urllib.parse
import logging
import pyperclip

class BitbucketParticipantsGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Bitbucket Participants Viewer")
        self.root.geometry("600x400")
        self.root.configure(bg="#2E2E2E")

        # Set up logging
        logging.basicConfig(filename="bitbucket_participants.log", level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")

        # Bitbucket API settings
        self.base_url = "https://crm.bitbucket.com/rest/api/latest"
        self.token = "your-api-token"  # Replace with your actual API token
        self.headers = {
            "Authorization": f"Bearer {self.token}",
            "Accept": "application/json"
        }

        # Loading indicator
        self.loading = False
        self.loading_label = None

        # GUI Elements
        self.create_widgets()

        # Fetch projects
        self.fetch_projects()

    def create_widgets(self):
        # Main frame
        main_frame = tk.Frame(self.root, bg="#2E2E2E", padx=20, pady=20)
        main_frame.pack(fill="both", expand=True)

        # Title
        title_label = tk.Label(main_frame, text="Bitbucket Participants", font=("Helvetica", 16, "bold"), fg="#FFFFFF", bg="#2E2E2E")
        title_label.pack(pady=10)

        # Project Combobox
        tk.Label(main_frame, text="Select Project:", font=("Helvetica", 10), fg="#FFFFFF", bg="#2E2E2E").pack(anchor="w")
        self.project_var = tk.StringVar()
        self.project_combo = ttk.Combobox(main_frame, textvariable=self.project_var, width=50, font=("Helvetica", 10), state="readonly")
        self.project_combo.pack(pady=5)
        self.project_combo.bind('<<ComboboxSelected>>', self.on_project_select)

        # Repository Combobox
        tk.Label(main_frame, text="Select Repository:", font=("Helvetica", 10), fg="#FFFFFF", bg="#2E2E2E").pack(anchor="w")
        self.repo_var = tk.StringVar()
        self.repo_combo = ttk.Combobox(main_frame, textvariable=self.repo_var, width=50, font=("Helvetica", 10), state="readonly")
        self.repo_combo.pack(pady=5)

        # Buttons
        button_frame = tk.Frame(main_frame, bg="#2E2E2E")
        button_frame.pack(pady=20)

        self.show_button = tk.Button(button_frame, text="Show Participants", command=self.show_participants,
                                     font=("Helvetica", 10), bg="#4CAF50", fg="#FFFFFF", relief="flat",
                                     activebackground="#45A049", padx=10, pady=5)
        self.show_button.pack(side="left", padx=10)
        self.show_button.bind("<Enter>", lambda e: self.show_button.config(bg="#66BB6A"))
        self.show_button.bind("<Leave>", lambda e: self.show_button.config(bg="#4CAF50"))

        self.clear_button = tk.Button(button_frame, text="Clear", command=self.clear_inputs,
                                      font=("Helvetica", 10), bg="#F44336", fg="#FFFFFF", relief="flat",
                                      activebackground="#D32F2F", padx=10, pady=5)
        self.clear_button.pack(side="left", padx=10)
        self.clear_button.bind("<Enter>", lambda e: self.clear_button.config(bg="#EF5350"))
        self.clear_button.bind("<Leave>", lambda e: self.clear_button.config(bg="#F44336"))

        # Loading label (hidden initially)
        self.loading_label = tk.Label(main_frame, text="Loading...", font=("Helvetica", 10), fg="#FFFFFF", bg="#2E2E2E")
        self.animate_loading()

    def animate_loading(self):
        if self.loading:
            current_text = self.loading_label.cget("text")
            new_text = current_text + "." if len(current_text) < 10 else "Loading..."
            self.loading_label.config(text=new_text)
            self.root.after(500, self.animate_loading)
        else:
            self.loading_label.pack_forget()

    def clear_inputs(self):
        self.project_var.set("")
        self.repo_var.set("")
        self.repo_combo['values'] = []
        self.project_combo.focus_set()

    def fetch_projects(self):
        self.loading = True
        self.loading_label.pack(pady=10)
        threading.Thread(target=self._fetch_projects_thread, daemon=True).start()

    def _fetch_projects_thread(self):
        try:
            response = requests.get(f"{self.base_url}/projects?limit=1000", headers=self.headers)
            response.raise_for_status()
            projects = response.json().get("values", [])
            logging.debug(f"Projects fetched: {len(projects)} projects")
            project_keys = sorted([project["key"] for project in projects])  # Sort for user-friendliness
            self.root.after(0, lambda: self.project_combo.configure(values=project_keys))
            if project_keys:
                self.root.after(0, lambda: self.project_var.set(project_keys[0]))
        except requests.RequestException as e:
            logging.error(f"Failed to fetch projects: {str(e)}")
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to fetch projects: {str(e)}"))
        finally:
            self.root.after(0, lambda: setattr(self, "loading", False))

    def on_project_select(self, event):
        project_key = self.project_var.get()
        if project_key:
            self.loading = True
            self.loading_label.pack(pady=10)
            threading.Thread(target=self._fetch_repos_thread, args=(project_key,), daemon=True).start()

    def _fetch_repos_thread(self, project_key):
        try:
            response = requests.get(f"{self.base_url}/projects/{project_key}/repos?limit=1000", headers=self.headers)
            response.raise_for_status()
            repos = response.json().get("values", [])
            logging.debug(f"Repositories fetched for {project_key}: {len(repos)} repos")
            repo_names = sorted([repo["name"] for repo in repos])  # Sort for user-friendliness
            self.root.after(0, lambda: self.repo_combo.configure(values=repo_names))
            if repo_names:
                self.root.after(0, lambda: self.repo_var.set(repo_names[0]))
            else:
                self.root.after(0, lambda: self.repo_combo.configure(values=[]))
        except requests.RequestException as e:
            logging.error(f"Failed to fetch repositories for {project_key}: {str(e)}")
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to fetch repositories: {str(e)}"))
        finally:
            self.root.after(0, lambda: setattr(self, "loading", False))

    def show_participants(self):
        project_key = self.project_var.get()
        repo_name = self.repo_var.get()

        if not project_key or not repo_name:
            messagebox.showerror("Error", "Please select a project and repository.")
            return

        self.loading = True
        self.loading_label.pack(pady=10)
        threading.Thread(target=self._fetch_participants_thread, args=(project_key, repo_name), daemon=True).start()

    def _fetch_participants_thread(self, project_key, repo_name):
        try:
            encoded_repo = urllib.parse.quote(repo_name, safe='')
            url = f"{self.base_url}/projects/{project_key}/repos/{encoded_repo}/participants"
            response = requests.get(url, headers=self.headers)
            logging.debug(f"Participants URL: {url}, Status: {response.status_code}, Response: {response.text}")
            response.raise_for_status()
            participants = response.json().get("values", [])
            self.root.after(0, lambda: self.display_participants(participants))
        except requests.RequestException as e:
            logging.error(f"Failed to fetch participants: {str(e)}")
            self.root.after(0, lambda: messagebox.showerror("Error", f"Failed to fetch participants: {str(e)}"))
        finally:
            self.root.after(0, lambda: setattr(self, "loading", False))

    def display_participants(self, participants):
        # Create popup window
        popup = Toplevel(self.root)
        popup.title("Repository Participants")
        popup.geometry("600x400")
        popup.configure(bg="#2E2E2E")
        popup.transient(self.root)
        popup.grab_set()

        # Table frame
        table_frame = tk.Frame(popup, bg="#2E2E2E", padx=10, pady=10)
        table_frame.pack(fill="both", expand=True)

        # Table
        columns = ("Name", "Email")
        tree = ttk.Treeview(table_frame, columns=columns, show="headings", height=15)
        tree.heading("Name", text="Display Name")
        tree.heading("Email", text="Email Address")
        tree.column("Name", width=300)
        tree.column("Email", width=300)
        tree.pack(side="left", fill="both", expand=True)

        # Scrollbar
        scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
        scrollbar.pack(side="right", fill="y")
        tree.configure(yscrollcommand=scrollbar.set)

        # Style
        style = ttk.Style()
        style.configure("Treeview", background="#3C3C3C", foreground="#FFFFFF", fieldbackground="#3C3C3C")
        style.configure("Treeview.Heading", font=("Helvetica", 10, "bold"), background="#4CAF50", foreground="#FFFFFF")

        # Populate table
        for participant in participants:
            user = participant.get("user", {})
            display_name = user.get("displayName", "N/A")
            email = user.get("emailAddress", "N/A")
            tree.insert("", "end", values=(display_name, email))

        # Copy to Clipboard button
        copy_button = tk.Button(popup, text="Copy to Clipboard", command=lambda: self.copy_to_clipboard(tree),
                                font=("Helvetica", 10), bg="#2196F3", fg="#FFFFFF", relief="flat",
                                activebackground="#1976D2", padx=10, pady=5)
        copy_button.pack(pady=10)
        copy_button.bind("<Enter>", lambda e: copy_button.config(bg="#42A5F5"))
        copy_button.bind("<Leave>", lambda e: copy_button.config(bg="#2196F3"))

    def copy_to_clipboard(self, tree):
        data = []
        for item in tree.get_children():
            values = tree.item(item)["values"]
            data.append("\t".join(str(v) for v in values))
        pyperclip.copy("\n".join(data))
        messagebox.showinfo("Info", "Table data copied to clipboard!")

if __name__ == "__main__":
    root = tk.Tk()
    app = BitbucketParticipantsGUI(root)
    root.mainloop()