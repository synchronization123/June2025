import tkinter as tk
from tkinter import ttk, messagebox
from atlassian import Bitbucket
from datetime import datetime

class BitbucketBlameGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Bitbucket Blame Viewer")
        self.root.geometry("800x600")

        # Bitbucket connection using API token
        self.bitbucket = Bitbucket(
            url="https://crm.bitbucket.com",  # Your Bitbucket Data Center URL
            token="your-api-token"           # Replace with your actual API token
        )

        # GUI Elements
        self.create_widgets()

        # Fetch projects and populate dropdown
        self.populate_projects()

    def create_widgets(self):
        # Project Dropdown
        tk.Label(self.root, text="Select Project:").pack(pady=5)
        self.project_var = tk.StringVar()
        self.project_dropdown = ttk.Combobox(self.root, textvariable=self.project_var, state="readonly")
        self.project_dropdown.pack(pady=5)
        self.project_dropdown.bind("<<ComboboxSelected>>", self.populate_repos)

        # Repository Dropdown
        tk.Label(self.root, text="Select Repository:").pack(pady=5)
        self.repo_var = tk.StringVar()
        self.repo_dropdown = ttk.Combobox(self.root, textvariable=self.repo_var, state="readonly")
        self.repo_dropdown.pack(pady=5)

        # Filename Input
        tk.Label(self.root, text="Enter Filename (e.g., README.md):").pack(pady=5)
        self.filename_entry = tk.Entry(self.root)
        self.filename_entry.pack(pady=5)

        # Author Filter
        tk.Label(self.root, text="Filter by Author (optional):").pack(pady=5)
        self.author_entry = tk.Entry(self.root)
        self.author_entry.pack(pady=5)

        # Date Range Filter
        tk.Label(self.root, text="Start Date (YYYY-MM-DD, optional):").pack(pady=5)
        self.start_date_entry = tk.Entry(self.root)
        self.start_date_entry.pack(pady=5)

        tk.Label(self.root, text="End Date (YYYY-MM-DD, optional):").pack(pady=5)
        self.end_date_entry = tk.Entry(self.root)
        self.end_date_entry.pack(pady=5)

        # Show Button
        self.show_button = tk.Button(self.root, text="Show Blame", command=self.display_blame)
        self.show_button.pack(pady=10)

        # Text Area with Scrollbar
        self.text_frame = tk.Frame(self.root)
        self.text_frame.pack(pady=10, fill="both", expand=True)

        self.output_text = tk.Text(self.text_frame, height=20, width=80, wrap="none")
        self.output_text.pack(side="left", fill="both", expand=True)

        scrollbar = tk.Scrollbar(self.text_frame, orient="vertical", command=self.output_text.yview)
        scrollbar.pack(side="right", fill="y")
        self.output_text.config(yscrollcommand=scrollbar.set)

        # Configure tags for text coloring
        self.output_text.tag_configure("green", foreground="green")
        self.output_text.tag_configure("normal", foreground="black")

    def populate_projects(self):
        try:
            projects = self.bitbucket.project_list()
            project_keys = [project["key"] for project in projects]
            self.project_dropdown["values"] = project_keys
            if project_keys:
                self.project_var.set(project_keys[0])
                self.populate_repos(None)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to fetch projects: {str(e)}")

    def populate_repos(self, event):
        project_key = self.project_var.get()
        try:
            repos = self.bitbucket.repo_list(project_key)
            repo_names = [repo["name"] for repo in repos]
            self.repo_dropdown["values"] = repo_names
            if repo_names:
                self.repo_var.set(repo_names[0])
        except Exception as e:
            messagebox.showerror("Error", f"Failed to fetch repositories: {str(e)}")

    def validate_date(self, date_str):
        if not date_str:
            return None
        try:
            return datetime.strptime(date_str, "%Y-%m-%d")
        except ValueError:
            messagebox.showerror("Error", "Invalid date format. Use YYYY-MM-DD.")
            return False

    def display_blame(self):
        project_key = self.project_var.get()
        repo_name = self.repo_var.get()
        filename = self.filename_entry.get().strip()
        author = self.author_entry.get().strip()
        start_date = self.start_date_entry.get().strip()
        end_date = self.end_date_entry.get().strip()

        # Validate inputs
        if not project_key or not repo_name or not filename:
            messagebox.showerror("Error", "Please select a project, repository, and enter a filename.")
            return

        # Validate date inputs
        start_dt = self.validate_date(start_date)
        end_dt = self.validate_date(end_date)
        if start_dt is False or end_dt is False:
            return
        if start_dt and end_dt and start_dt > end_dt:
            messagebox.showerror("Error", "Start date must be before end date.")
            return

        # Clear previous output
        self.output_text.delete(1.0, tk.END)

        try:
            # Fetch commit history for the file
            commits = self.bitbucket.get_commits(project_key, repo_name, path=filename, limit=100)

            if not commits:
                messagebox.showerror("Error", f"No commits found for file: {filename}")
                return

            filtered_commits = []
            for commit in commits:
                commit_date = datetime.fromtimestamp(commit["authorTimestamp"] / 1000)
                commit_author = commit["author"]["name"]

                # Apply filters
                if author and author.lower() not in commit_author.lower():
                    continue
                if start_dt and commit_date < start_dt:
                    continue
                if end_dt and commit_date > end_dt:
                    continue

                filtered_commits.append(commit)

            if not filtered_commits:
                messagebox.showerror("Error", "No commits match the specified filters.")
                return

            for commit in filtered_commits:
                commit_id = commit["id"]
                commit_date = datetime.fromtimestamp(commit["authorTimestamp"] / 1000).strftime("%Y-%m-%d %H:%M:%S")
                commit_author = commit["author"]["name"]
                commit_message = commit.get("message", "No commit message")

                # Fetch the diff for this commit
                diff = self.bitbucket.get_commit(project_key, repo_name, commit_id)["diffs"]
                changed_lines = []

                # Parse diff for the specific file
                for diff_item in diff:
                    if diff_item.get("source") == filename or diff_item.get("destination") == filename:
                        for hunk in diff_item.get("hunks", []):
                            for line in hunk.get("lines", []):
                                if line["type"] == "ADDED":
                                    changed_lines.append(line["line"])

                # Display commit info and changed lines
                output = f"Commit: {commit_id}\nDate: {commit_date}\nAuthor: {commit_author}\nMessage: {commit_message}\n"
                self.output_text.insert(tk.END, output, "normal")
                
                if changed_lines:
                    for line in changed_lines:
                        self.output_text.insert(tk.END, f"Code: {line}\n", "green")
                else:
                    self.output_text.insert(tk.END, "Code: No added lines in this commit\n", "green")
                self.output_text.insert(tk.END, "\n", "normal")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to retrieve blame information: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = BitbucketBlameGUI(root)
    root.mainloop()